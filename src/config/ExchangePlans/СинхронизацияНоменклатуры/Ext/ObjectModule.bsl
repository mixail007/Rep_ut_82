////////////////////////////////////////////////////////////////////////////////
// ЭКСПОРТНЫЕ ПРОЦЕДУРЫ
// 

// Процедура записи сообщения с измененными данными
//
Процедура ЗаписатьСообщениеСИзменениями() Экспорт
	
	// Формируем имя временного файла
	ИмяФайла = КаталогВременныхФайлов() + "\" + 
			   ПолучитьИмяФайлаОбмена(ПланыОбмена.СинхронизацияНоменклатуры.ЭтотУзел(), Ссылка, "_W");
	
	Если Инфо() Тогда
		Сообщить("-------- Выгрузка в узел " + Строка(ЭтотОбъект) + " ------------");
	КонецЕсли;
	
	// Записываем новое сообщение обмена в файл
	НомерСообщения = ЗаписатьНовоеСообщение(ИмяФайла);
	
	// Публикуем файл с сообщением обмена
	ОпубликоватьФайлОбмена(ИмяФайла, НомерСообщения);
		
	Попытка
		
		// Удаляем файл с сообщением обмена
		УдалитьФайлы(ИмяФайла);
		
	Исключение
		
	КонецПопытки;	
	Если Инфо() Тогда 
		Сообщить("-------- Конец выгрузки------------");
	КонецЕсли;
	
КонецПроцедуры // ЗаписатьСообщениеСИзменениями()

// Процедура получения сообщения обмена данными
// Получает сообщение с новыми данными для этого узла и загружает данные
//
Процедура ПрочитатьСообщениеСИзменениями() Экспорт
	
	Перем НомерСообщения;	// Номер принимаемого сообщения
	
	// Формируем имя временного файла
	ИмяФайла = КаталогВременныхФайлов() + "\" + 
			   ПолучитьИмяФайлаОбмена(ПланыОбмена.СинхронизацияНоменклатуры.ЭтотУзел(), Ссылка, "_R");
	
	Если Инфо() Тогда
	
			Сообщить("-------- Загрузка из " + Строка(ЭтотОбъект) + "------------");	
	
	КонецЕсли; 		   

	
	// Получаем копию файла обмена с новым сообщением во временный файл
		ФайлПолучен = ПолучитьФайлОбмена(ИмяФайла);
		
	
	Если ФайлПолучен Тогда
		
		Попытка
			
			// Читаем полученное сообщение из файла	
			НомерСообщения = ПрочитатьНовоеСообщение(ИмяФайла);
			
		Исключение
			
			Если Инфо() Тогда 
				Сообщить("    " + ОписаниеОшибки());
			КонецЕсли;
			
		КонецПопытки;
		
		Если НомерСообщения <> Неопределено Тогда
			
			// Удаляем файлы со старыми сообщениями обмена
			УдалитьФайлыОбмена(НомерСообщения);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Попытка
		
		// Удаляем файл с сообщением обмена
		УдалитьФайлы(ИмяФайла);
		
	Исключение
	КонецПопытки;
	
	Если Инфо() Тогда 
		Сообщить("-------- Конец загрузки------------");
	КонецЕсли;
	
КонецПроцедуры // ПрочитатьСообщениеСИзменениями()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ
 
// Функция выполняет проверку того, что данные нужно переностить в данный узел
//
// Параметры:
//  Данные	– Объект, набор записей,... который нужно проверить.
//            То, что переносится везде, не обрабатывается
//
// Возвращаемое значение:
//  Перенос - булево, если Истина - необходимо выполнять перенос, 
//			  иначе - перенос выполнять не нужно
//
Функция НуженПереносДанных(Данные)
	
	Перенос = Истина;
	
	Если ТипЗнч(Данные) = Тип("СправочникОбъект.Номенклатура") Тогда
		Если Константы.ОтсекатьПрочее.Получить() Тогда
			
			// Проверяем, что у номенклатуры нужный вид  
			Если Данные.ВидТовара = Перечисления.ВидыТоваров.Прочее Тогда
				
				Перенос = Ложь;
				
			КонецЕсли;	
			
			
		КонецЕсли; 

		
	КонецЕсли;	
		
	Возврат Перенос;
	
КонецФункции // НуженПереносДанных()

// Процедура вывода диагностической информации о данных
//
// Параметры:
//  Данные	– Объект, набор записей,... информацию о которых нужно выводить
//
Процедура ВывестиДанные(Данные)
	
	Перем Представление;
	
	Если ТипЗнч(Данные) = Тип("УдалениеОбъекта") Тогда
		
		Представление = "Удаление объекта: " + Строка(Данные.Ссылка.Метаданные()) + 
						": " + Строка(Данные.Ссылка);
	Иначе					
		
		Представление = Строка(Данные.Метаданные()) + ": " + Строка(Данные);		
		
	КонецЕсли;
	Если Инфо() Тогда
		Сообщить("- " + Представление);
	КонецЕсли; 
КонецПроцедуры // ВывестиДанные()

// Процедура на основании анализа типа данных заменяет их на данные, удаляющие
// информацию из узла в котором их не должно быть
//
// Параметры:
//  Данные	– Объект, набор записей,... который нужно преобразовать
//
Процедура УдалениеДанных(Данные) 
	
	// Получаем объект описания метаданного, соответствующий данным
	ОбъектМетаданных = ?(ТипЗнч(Данные) = Тип("УдалениеОбъекта"), Данные.Ссылка.Метаданные(), Данные.Метаданные());
	
	Если Метаданные.Справочники.Содержит(ОбъектМетаданных)
	 Или Метаданные.Документы.Содержит(ОбъектМетаданных)
	 Или Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных)
	 Или Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных)
	 Или Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		
		// Перенос удаления объекта для объектных
		Данные = Новый УдалениеОбъекта(Данные.Ссылка);
		
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных)
		  Или Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных)
		  Или Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных)
		  Или Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных)
		  Или Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных.Родитель)
		  Или Метаданные.Последовательности.Содержит(ОбъектМетаданных) Тогда
		
		// Очищаем данные
		Данные.Очистить();
		
	КонецЕсли;	
	
КонецПроцедуры // УдалениеДанных(Данные)

// Функция записи нового сообщения обмена в файл
// 
// Параметры:
//  ИмяФайла	- имя файла, в который будет записано сообщение обмена
//  ПланОбмена	- ссылка на план обмена, для которого формируется сообщение обмена
//
// Возвращаемое значение:
//  НомерСообщения - номер сообщения записанного в файл обмена
//
Функция ЗаписатьНовоеСообщение(ИмяФайла)
	
	НомерСообщения = 0;
	// Создаем объект записи XML
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ИмяФайла);
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	
	// Создаем новое сообщение
	ЗаписьСообщения = ПланыОбмена.СоздатьЗаписьСообщения();
	ЗаписьСообщения.НачатьЗапись(ЗаписьXML, Ссылка);
	
	// Для сокращения размера файла сообщения записываем соответствие пространств имен
	ЗаписьXML.ЗаписатьСоответствиеПространстваИмен("xsd", "http://www.w3.org/2001/XMLSchema");
	ЗаписьXML.ЗаписатьСоответствиеПространстваИмен("xsi", "http://www.w3.org/2001/XMLSchema-instance");
	ЗаписьXML.ЗаписатьСоответствиеПространстваИмен("v8", "http://v8.1c.ru/data");
	
	НомерСообщения = ЗаписьСообщения.НомерСообщения;
	Если Инфо() Тогда 
		Сообщить("    Номер сообщения: " + НомерСообщения);
	КонецЕсли;
	
	// Получаем выборку изменённых данных
	Счетчик = 0;
	ВыборкаИзменений = ПланыОбмена.ВыбратьИзменения(ЗаписьСообщения.Получатель, НомерСообщения);
	
	Пока ВыборкаИзменений.Следующий() Цикл
		
		Данные = ВыборкаИзменений.Получить();
		
		Счетчик = Счетчик + 1;
		Если Инфо() Тогда 
			Состояние("Выгрузка данных: " + Строка(Счетчик));
		КонецЕсли;
		
		 //Если перенос данных не нужен, то, возможно, необходимо записать удаление данных
		 
		 Если Не НуженПереносДанных(Данные) Тогда
			
			// Получаем значение с возможным удалением данных
			УдалениеДанных(Данные); 
			
		 КонецЕсли;
		 

		// Записываем данные в сообщение
		ЗаписатьДанные(ЗаписьXML, Данные);
		
		// Выводим диагностическое сообщение о записанных данных
		ВывестиДанные(Данные);
		
	КонецЦикла;
	
	// Завершаем запись сообщения
	ЗаписьСообщения.ЗакончитьЗапись();
	ЗаписьXML.Закрыть();
	
	Возврат НомерСообщения;
	
КонецФункции // ЗаписатьНовоеСообщение(ИмяФайла)

// Функция чтения нового сообщения обмена из файла
//
// Параметры:
//  ИмяФайла - имя файла с сообщением обмена
// 
// Возвращаемое значение:
//  НомерСообщения - номер принятого сообщения
//
Функция ПрочитатьНовоеСообщение(ИмяФайла)
	
	// Создаем объект чтения XML
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ИмяФайла);
	
	// Загрузка из найденного файла
	ЧтениеСообщения = ПланыОбмена.СоздатьЧтениеСообщения();
	ЧтениеСообщения.НачатьЧтение(ЧтениеXML);
	НомерСообщения = ЧтениеСообщения.НомерСообщения;
	Если ЧтениеСообщения.Отправитель <> Ссылка Тогда
		
		// Сообщение предназначено не для этого узла
		ВызватьИсключение "Неверный узел";
		
	КонецЕсли;
	
	// Удаляем регистрацию изменений для узла отправителя сообщения
	// по номеру принятого сообщения, полученного из сообщения
	ПланыОбмена.УдалитьРегистрациюИзменений(ЧтениеСообщения.Отправитель, ЧтениеСообщения.НомерПринятого);
	
	// Читаем данные из сообщения пока это возможно
	Счетчик = 0;
	Пока ВозможностьЧтенияДанных(ЧтениеXML) Цикл
		
		// Читаем очередное значение
		Данные = ПрочитатьДанные(ЧтениеXML);
		Счетчик = Счетчик + 1;
		Если Инфо() Тогда
		
			Состояние("Загрузка данных: " + Строка(Счетчик));	
		
		КонецЕсли; 
		
		
		// Разрешение коллизий при одновременном изменении в обоих узлах
		Если Не ЧтениеСообщения.Отправитель.Главный 
		   И ПланыОбмена.ИзменениеЗарегистрировано(ЧтениеСообщения.Отправитель, Данные) Тогда
			
			Если Инфо() Тогда
			
				Сообщить("- Изменения отклонены:");
			
			КонецЕсли; 
			
			ВывестиДанные(Данные);
			
			Продолжить;
			
		КонецЕсли;
		
		// Вывод диагностического сообщения о загружаемых данных
		ВывестиДанные(Данные);
		// Устанавливаем отправителя, чтобы для него при записи не было бы зарегистрировано изменение
		Данные.ОбменДанными.Отправитель = ЧтениеСообщения.Отправитель;
		// Включает режим Загрузка, так как данные могут загружаться в произвольном порядке и 
        // нужно отключить такой контроль данных, как проверка уникальности номеров
		Данные.ОбменДанными.Загрузка = Истина;
		
		//***2015.10.05 заглушка, т.к. Номенклатурные группы из Формулы все равно как-то просачивались иногда
		Если ТипЗНЧ(Данные) = Тип("СправочникСсылка.НоменклатурныеГруппы") Тогда
			Если ЧтениеСообщения.Отправитель = ПланыОбмена.СинхронизацияНоменклатуры.НайтиПоКоду("F") Тогда //Формула
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		//***
		
		Если ТипЗнч(Данные) = Тип("СправочникОбъект.Номенклатура") Тогда
			
			Если НЕ Данные.ЭтоГруппа Тогда
				
				Если Константы.МенятьСтавку.Получить() Тогда
					
					// Устанавливаем ставку НДС по умолчанию  
					Данные.СтавкаНДС = Константы.СтавкаНДС.Получить();
					
					
				КонецЕсли;
				
				//*** апрель 2014
				//чтоб не перезаписывалась номенклатурная группа из Формулы
				Если ЧтениеСообщения.Отправитель = ПланыОбмена.СинхронизацияНоменклатуры.НайтиПоКоду("F") Тогда //Формула
					ЭлемНом = Справочники.Номенклатура.НайтиПоКоду(Данные.Код);
					Данные.НоменклатурнаяГруппа = ЭлемНом.НоменклатурнаяГруппа;
				КонецЕсли;
				//**
				
			КонецЕсли;
			
		КонецЕсли;
		
		// Запись перенесенных данных
		Данные.Записать();
		
	КонецЦикла;
	
	ЧтениеСообщения.ЗакончитьЧтение();
	ЧтениеXML.Закрыть();
	
	Возврат НомерСообщения;
	
КонецФункции // ПрочитатьНовоеСообщение(ИмяФайла)

// Процедура записывает данных в формат XML
// Процедура анализирует переданный объект данных и на основе этого анализа
// записывает его определенным образом в формат XML
//
// Параметры:
//  ЗаписьXML	- объект, записывающий XML данные
//  Данные 		- данные, подлежащие записи в формат XML
//
Процедура ЗаписатьДанные(ЗаписьXML, Данные)
	
	Удаление = ?(ТипЗнч(Данные) = Тип("УдалениеОбъекта"), Истина, Ложь);
	// Получаем объект описания метаданного, соответствующий данным
	ОбъектМетаданных = ?(Удаление, Данные.Ссылка.Метаданные(), Данные.Метаданные());
	
	// Если выгружаемыми данными является Справочник.Номенклатура, то его выгружаем вручную
	Если (Не Удаление И ОбъектМетаданных = Метаданные.Справочники.Номенклатура) И (Константы.ОсобоеЧтениеНоменклатуры.Получить()) Тогда
		
		// Записываем элемент справочника вручную
		НоменклатураЗаписатьXML(ЗаписьXML, Данные);
		
	Иначе
		
		// Записываем данные с помощью стандартного метода
		ЗаписатьXML(ЗаписьXML, Данные);
		
	КонецЕсли
	
КонецПроцедуры // ЗаписатьДанные(ЗаписьXML, Данные)

// Функция определяет возвможность чтения очередных данных из объекта ЧтениеXML
//
// Параметры:
//  ЧтениеXML - объект чтения XML
//
// Вовзращаемое значение:
//  Булево - Истина, если возможно чтение очередных данных или Ложь - в противном случае
//
Функция ВозможностьЧтенияДанных(ЧтениеXML)
	
	// Получаем тип данных XML, который может быть считан в данный момент
	ТипXML = ПолучитьXMLТип(ЧтениеXML);
	Если ТипXML = Неопределено Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Если ТипXML.ИмяТипа = "CatalogObject.Номенклатура.Вручную" 
	   И ТипXML.URIПространстваИмен = "" Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Возврат ВозможностьЧтенияXML(ЧтениеXML);
	
КонецФункции // ВозможностьЧтенияДанных(ЧтениеXML)

// Функция читает данные из формат XML
// Процедура анализирует переданный объект ЧтениеXML и на основе этого анализа
// читает из него данные определенным образом
//
// Параметры:
//  ЧтениеXML	- объект, читающий XML данные
//
// Возвращаемое значение:
//  Данные - значение, прочитанное из объекта ЧтениеXML
//
Функция ПрочитатьДанные(ЧтениеXML)
	
	ТипXML = ПолучитьXMLТип(ЧтениеXML);
	Если ТипXML = Неопределено Тогда
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Если ТипXML.ИмяТипа = "CatalogObject.Номенклатура.Вручную" 
	   И ТипXML.URIПространстваИмен = "" Тогда
		
		// Пытаемся прочесть значение справочника Номеклатура
		Возврат НомеклатураПрочитатьXML(ЧтениеXML);
		
	КонецЕсли;
	
	// Пытаемся прочесть значени из объекта ЧтениеXML стандартным образом
	Возврат ПрочитатьXML(ЧтениеXML);
	
КонецФункции // ПрочитатьДанные(ЧтениеXML)

// Процедура записывает в объект ЗаписьXML значение элемента справочника Номеклатура
//
// Параметры:
//  ЗаписьXML		- объект, записывающий XML данные
//  Номенклатура	- ссылка на элемент справочника Номенклатура
//
Процедура НоменклатураЗаписатьXML(ЗаписьXML, Номенклатура)
	
	// Записываем начало элемента XML
	ЗаписьXML.ЗаписатьНачалоЭлемента("CatalogObject.Номенклатура.Вручную");
	
	// Ссылка
	ЗаписатьXML(ЗаписьXML, Номенклатура.Ссылка, "Ref", НазначениеТипаXML.Явное);
	// ЭтоГруппа
	ЗаписатьXML(ЗаписьXML, Номенклатура.ЭтоГруппа, "IsFolder", НазначениеТипаXML.Явное);
	// Родитель
	ЗаписатьXML(ЗаписьXML, Номенклатура.Родитель, "Parent", НазначениеТипаXML.Явное);
	// Код
	ЗаписатьXML(ЗаписьXML, Номенклатура.Код, "Code", НазначениеТипаXML.Явное);
	// Наименование
	ЗаписатьXML(ЗаписьXML, Номенклатура.Наименование, "Description", НазначениеТипаXML.Явное);
	// Реквизиты, выгружаемые только для элемента справочника, а не для группы
	//Если Не Номенклатура.ЭтоГруппа Тогда 
	//	
	//	// ЗакупочнаяЦена
	//	ЗаписатьXML(ЗаписьXML, Номенклатура.ЗакупочнаяЦена, "ЗакупочнаяЦена", НазначениеТипаXML.Явное);
	//	// Картинка
	//	ЗаписатьXML(ЗаписьXML, Номенклатура.Картинка, "Картинка", НазначениеТипаXML.Явное);
	//	// ПолноеНаименование
	//	ЗаписатьXML(ЗаписьXML, Номенклатура.ПолноеНаименование, "ПолноеНаименование", НазначениеТипаXML.Явное);
	//	
	//КонецЕсли;
	
	// Записываем конец элемента
	ЗаписьXML.ЗаписатьКонецЭлемента();
	
КонецПроцедуры // НоменклатураЗаписатьXML(ЗаписьXML, Номенклатура)

// Функция читает из объекта ЧтениеXML значение элемента справочника Номеклатура
//
// Параметры:
//  ЧтениеXML	- объект, читающий XML данные
//
// Возвращаемое значение:
//  Номеклатура	- ссылка на элемент справочника Номенклатура
//
Функция НомеклатураПрочитатьXML(ЧтениеXML)
	
	Перем Номенклатура;	// элемент справочника Номенклатура
	
	Если ЧтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
		
		ВызватьИсключение "Ошибка чтения XML";
		
	КонецЕсли;
	
	// Чтение следующего узла
	ЧтениеXML.Прочитать();
	
	// Чтение ссылки на элемент справочника
	НомеклатураСсылка = ПрочитатьXML(ЧтениеXML);
	Если ТипЗнч(НомеклатураСсылка) <> Тип("СправочникСсылка.Номенклатура") Тогда
		
		ВызватьИсключение "Ошибка чтения XML";
		
	КонецЕсли;
	
	// Пытаемся создать объект по полученной ссылке
	Номенклатура = НомеклатураСсылка.ПолучитьОбъект();
	
	// Чтение признака группы
	ЭтоГруппа = ПрочитатьXML(ЧтениеXML);
	
	Если Номенклатура <> Неопределено Тогда
		
		Если Номенклатура.ЭтоГруппа <> ЭтоГруппа Тогда
			
			ВызватьИсключение "Некорректные данные";
			
		КонецЕсли;
		
	Иначе
		
		// Создаем элемент справочника
		Если ЭтоГруппа = Истина Тогда
			
			// Создаем группу
			Номенклатура = Справочники.Номенклатура.СоздатьГруппу();
			
		Иначе
			
			// Создаем элемент справочника
			Номенклатура = Справочники.Номенклатура.СоздатьЭлемент();
			
		КонецЕсли;
		
		// Устанавливаем значение ссылки для нового объекта
		Номенклатура.УстановитьСсылкуНового(НомеклатураСсылка);
		
	КонецЕсли;
	
	// Родитель
	Номенклатура.Родитель = ПрочитатьXML(ЧтениеXML);
	// Код
	Номенклатура.Код = ПрочитатьXML(ЧтениеXML);
	// Наименование
	Номенклатура.Наименование = ПрочитатьXML(ЧтениеXML);
	// Реквизиты, загружаемые только для элемента справочника, а не для группы
	Если Не Номенклатура.ЭтоГруппа Тогда 
		
		// ЗакупочнаяЦена
		//Номенклатура.ЗакупочнаяЦена = ПрочитатьXML(ЧтениеXML);
		// Картинка
		//Номенклатура.Картинка = ПрочитатьXML(ЧтениеXML);
		// ПолноеНаименование
		//Номенклатура.ПолноеНаименование = ПрочитатьXML(ЧтениеXML);
		
	КонецЕсли;
	
	// Проверяем, что текущим узлом является КонецЭлемента
	Если ЧтениеXML.ТипУзла <> ТипУзлаXML.КонецЭлемента Тогда
		
		ВызватьИсключение "Ошибка чтения XML";
		
	КонецЕсли;
	
	// Чтение следующего узла для завершение чтения элемента
	ЧтениеXML.Прочитать();
	
	Возврат Номенклатура;
	
КонецФункции	// НомеклатураПрочитатьXML(ЧтениеXML)

// Процедура публикации файла с сообщением обмена по электронной почте
//
// Параметры:
//  ИмяФайла 		- имя файла, содержащего сообщение обмена
//  НомерСообщения  - номер сообщения отправляемых данных
//
Процедура ОтправитьФайлОбмена(ИмяФайла, НомерСообщения)

	//Профиль = Новый ИнтернетПочтовыйПрофиль;
	//Профиль.АдресСервераSMTP = СерверSMTP;
	//
	//ИмяФайлаСообщения = ПолучитьИмяФайлаОбмена(ПланыОбмена.СинхронизацияНоменклатуры.ЭтотУзел(), 
	//Ссылка, Формат(НомерСообщения, "ЧЦ=10; ЧВН=; ЧГ=0"));
	//
	//// Формируем сообщение обмена
	//Сообщение = Новый ИнтернетПочтовоеСообщение;
	//Сообщение.Тема = "СООБЩЕНИЕ_ОБМЕНА: " + ИмяФайлаСообщения;
	//Сообщение.Получатели.Добавить(ПочтовыйАдресОбмена);
	//
	//ФайлСообщения = Новый Файл(ИмяФайлаСообщения);
	//// Создаем вложение с файлом обмена
	//Сообщение.Вложения.Добавить(ИмяФайла, ФайлСообщения.Имя);
	//
	//Почта = Новый ИнтернетПочта;
	//
	//Попытка
	//	
	//	Почта.Подключиться(Профиль);
	//	// Отправляем сообщение с файлом обмена
	//	Почта.Послать(Сообщение);
	//	
	//Исключение
	//	
	//	Сообщить(" - Ошибка при отправки файла: " + ИмяФайлаСообщения);
	//	Сообщить(ОписаниеОшибки());
	//	Возврат;
	//	
	//КонецПопытки;
	//
	//Сообщить(" - Отправлен файл " + ИмяФайлаСообщения + " на адрес " + ПочтовыйАдресОбмена);
	//
	//Почта.Отключиться();

КонецПроцедуры // ОтправитьФайлОбмена(ИмяФайла, НомерСообщения)

// Функция получения файла с новым сообщением обмена по электронной почте
// Ищет и записывает в указанный файл файл с последним сообщением обмена
//
// Параметры:
//  ИмяФайла - файл, в который будет записан файл с сообщением обмена
//
// Возвращаемое значение:
//  Булево - Истина - если файл с сообщением обмена получен и Ложь - в противном случае
//
Функция ПринятьФайлОбмена(ИмяФайла)

	//Профиль = Новый ИнтернетПочтовыйПрофиль;
	//Профиль.АдресСервераPOP3 = СерверPOP3;
	//Профиль.Пользователь = Пользователь;
	//Профиль.Пароль = Пароль;
	//
	//Попытка
	//	
	//	Почта = Новый ИнтернетПочта;
	//	Почта.Подключиться(Профиль);
	//	
	//	// Получаем все сообщения из почтового ящика
	//	МассивСообщений = Новый Массив;
	//	МассивСообщений = Почта.Выбрать(Ложь);
	//	
	//Исключение
	//	
	//	// Ошибка при подключении к серверу или при приеме сообщения обмена
	//	Сообщить(" - Ошибка при подключении или приеме" + ОписаниеОшибки());
	//	Возврат Ложь;
	//	
	//КонецПопытки;
	//
	//// Далее все оставшиеся сообщения в МассивСообщенийОбмена, и только они, 
	//// будут удалены с сервера. Это исключает удаление личных сообщений из
	//// почтового ящика.
	//МассивСообщенийОбмена = Новый Массив;
	//
	//Если МассивСообщений.Количество() = 0 Тогда
	//	
	//	// Сообщений в почтовом ящике нет
	//	Возврат Ложь;
	//	
	//КонецЕсли;
	//
	//ИмяФайлаСообщения = "";
	//Для Индекс = 0 По МассивСообщений.Количество() - 1 Цикл
	//	
	//	// Отсеиваем только сообщения, которые содержат файлы обмена 
	//	// для участвующих в обмене узлов.
	//	ЧастьТемы = "СООБЩЕНИЕ_ОБМЕНА: " + "Message" + СокрП(Ссылка.Код) + "_" + СокрП(ПланыОбмена.СинхронизацияНоменклатуры.ЭтотУзел().Код);
	//	Если Лев(МассивСообщений[Индекс].Тема, СтрДлина(ЧастьТемы)) = ЧастьТемы Тогда
	//		
	//		Если МассивСообщений[Индекс].Вложения[0].Имя > ИмяФайлаСообщения Тогда
	//			
	//			// Выбираем сообщение с последним номером сообщения обмена
	//			ИмяФайлаСообщения = МассивСообщений[Индекс].Вложения[0].Имя;
	//			ИндексСообщения = Индекс;
	//			
	//		КонецЕсли;	
	//		
	//		МассивСообщенийОбмена.Добавить(МассивСообщений[Индекс]);
	//		
	//	КонецЕсли;	
	//	
	//КонецЦикла;
	//
	//Если ИндексСообщения <> Неопределено Тогда 
	//	
	//	// Записываем файл обмена во временный файл
	//	МассивСообщений[ИндексСообщения].Вложения[0].Данные.Записать(ИмяФайла);
	//	
	//	Сообщить(" - Принят файл обмена данными " + ИмяФайлаСообщения + " с адреса " + ПочтовыйАдресОбмена);
	//	
	//	// Удаляем все сообщения обмена с сервера для узлов, участвующих в обмене
	//	Почта.УдалитьСообщения(МассивСообщенийОбмена);
	//	Почта.Отключиться();        
	//	Возврат Истина;
	//	
	//Иначе
	//	
	//	// Сообщений обмена в почтовом ящике нет
	//	Почта.Отключиться();        
	//	Возврат Ложь;
	//	
	//КонецЕсли;
	
КонецФункции // ПринятьФайлОбмена(ИмяФайла)

// Процедура публикации файла с сообщением обмена
//
// Параметры:
//  ИмяФайла 		- имя файла, содержащего сообщение обмена
//  НомерСообщения  - номер сообщения отправляемых данных
//
Процедура ОпубликоватьФайлОбмена(ИмяФайла, НомерСообщения)
	
	ИмяФайлаСообщения = ПолучитьИмяФайлаОбмена(ПланыОбмена.СинхронизацияНоменклатуры.ЭтотУзел(), 
	
	Ссылка, Формат(НомерСообщения, "ЧЦ=10; ЧВН=; ЧГ=0"));
	
	Путь = СтрЗаменить(АдресОбмена, "\", "/");
	// Копируем файл в каталог, определенный для данного узла
	Попытка
		
		КопироватьФайл(ИмяФайла, Путь + ?(Прав(Путь, 1) = "/", "", "/") + ИмяФайлаСообщения);
		
	Исключение
		
		Если Инфо() Тогда
		
			Сообщить(" - Ошибка публикации файла: " + ИмяФайлаСообщения);
			Сообщить(ОписаниеОшибки());

		
		КонецЕсли; 
		Возврат;
		
	КонецПопытки;
	
	Если Инфо() Тогда 
		Сообщить(" - Опубликован файл: " + ИмяФайлаСообщения);
	КонецЕсли;
	
	// Удаляем ранее выгруженные файлы
	ФайлСообщения = Новый Файл(ИмяФайлаСообщения);
	МаскаФайлов = ПолучитьИмяФайлаОбмена(ПланыОбмена.СинхронизацияНоменклатуры.ЭтотУзел(), Ссылка, "??????????");
	Файлы = НайтиФайлы(АдресОбмена, МаскаФайлов);
	Для Каждого Файл Из Файлы Цикл
		
		Если Файл.Имя <> ФайлСообщения.Имя Тогда
			
			Попытка
				
				// Пытаемся удалить файл со старым сообщением
				УдалитьФайлы(Файл.ПолноеИмя);
				
			Исключение
			КонецПопытки;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ОпубликоватьФайлОбмена(ИмяФайла, НомерСообщения)

// Функция получения файла с новым сообщением обмена
// Ищет и копирует в указанный файл файл с последним сообщением обмена
//
// Параметры:
//  ИмяФайла	- файл, в который будет произведено копирование файла с сообщением обмена
//
// Возвращаемое значение:
//  Булево - Истина - если файл с сообщением обмена получен и Ложь - в противном случае
//
Функция ПолучитьФайлОбмена(ИмяФайла)
	
	// Получаем маску для поиска файлов с сообщениями обмена
	МаскаФайлов = ПолучитьИмяФайлаОбмена(Ссылка, ПланыОбмена.СинхронизацияНоменклатуры.ЭтотУзел(), "??????????");
	
	ИмяФайлаСообщения = "";
	// Ищем файлы по маске в каталоге загрузки
	Файлы = НайтиФайлы(АдресОбмена, МаскаФайлов);
	// Отбираем файл с максимальным номером в имени
	Для Каждого Файл Из Файлы Цикл
		
		Если ПустаяСтрока(ИмяФайлаСообщения) Или Файл.ПолноеИмя > ИмяФайлаСообщения Тогда
			
			ИмяФайлаСообщения = Файл.ПолноеИмя;
			
		КонецЕсли;	
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(ИмяФайлаСообщения) Тогда
		Если Инфо()Тогда 
			Сообщить(" - Считывается файл " + ИмяФайлаСообщения);
		КонецЕсли;
		
		Попытка
			
			// Копируем файл с сообщением обмена в указанный файл
			КопироватьФайл(ИмяФайлаСообщения, ИмяФайла);
			
		Исключение
			Если Инфо() Тогда 
				Сообщить("   " + ОписаниеОшибки());
			КонецЕсли;
			Возврат Ложь;
			
		КонецПопытки;
		
		// Файл с сообщением обмена получен успешно
		Возврат Истина;
		
	КонецЕсли;	
	
	Возврат Ложь;
	
КонецФункции // ПолучитьФайлОбмена(ИмяФайла)

// Процедура удаления файлов со старыми сообщениями обмена
// Удаляет файлы с именами равными или меньшими переданному номеру сообщения
// 
// Параметры:
//  НомерСообщения - номер сообщения
//
Процедура УдалитьФайлыОбмена(НомерСообщения)
	
	// Получаем имя файла с номером сообщения
	МаксИмяФайла = ПолучитьИмяФайлаОбмена(Ссылка, ПланыОбмена.СинхронизацияНоменклатуры.ЭтотУзел(),
	Формат(НомерСообщения, "ЧЦ=10; ЧВН=; ЧГ=0")); 
	// Получаем маску для поиска файлов с сообщениями обмена
	МаскаФайлов = ПолучитьИмяФайлаОбмена(Ссылка, ПланыОбмена.СинхронизацияНоменклатуры.ЭтотУзел(), "??????????");
	
	// Ищем файлы по маске в каталоге загрузки
	Файлы = НайтиФайлы(АдресОбмена, МаскаФайлов);
	// Удаление файлов со старыми сообщениями обмена
	Для Каждого Файл Из Файлы Цикл
		
		// Удаляем только файлы, имена которых меньше или равны имени файла с указанным номером сообщения
		Если Файл.Имя <= МаксИмяФайла Тогда
			
			Попытка
				
				// Пытаемся удалить файл
				УдалитьФайлы(Файл.ПолноеИмя);
				
			Исключение
			КонецПопытки;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // УдалитьФайлыОбмена(НомерСообщения)

// Процедура размещения сообщения обмена в очереди
//
// Параметры:
//  ИмяФайла 		- имя файла, содержащего сообщение обмена
//  НомерСообщения  - номер сообщения отправляемых данных
//
Процедура ПоместитьДанныеОбменаВОчередь(ИмяФайла, НомерСообщения)
	
	//// Флаги
	//MQ_SEND_ACCESS = 2;
	//MQ_DENY_NONE = 0;

	//// Получаем имя файла с номером сообщения
	//ИмяФайлаСообщения = ПолучитьИмяФайлаОбмена(ПланыОбмена.СинхронизацияНоменклатуры.ЭтотУзел(), 
	//Ссылка, Формат(НомерСообщения, "ЧЦ=10; ЧВН=; ЧГ=0"));
	//
	//qinfo = Новый COMОбъект("MSMQ.MSMQQueueInfo");
	//// Формируем путь к очереди на удаленном компьютере
	//qinfo.PathName = ОчередьОбменаMSMQ + "_" + СокрП(Ссылка.Код);
	//
	//// Если очередь не создана, создаем
	//Попытка
	//	
	//	qinfo.Create();
	//	
	//Исключение
	//КонецПопытки;
	//
	//// Открываем очередь на запись
	//Очередь = qinfo.Open(MQ_SEND_ACCESS, MQ_DENY_NONE);
	//
	//ДанныеОбмена = Новый ЧтениеТекста;
	//ДанныеОбмена.Открыть(ИмяФайла);
	//
	//// Создаем сообщение, содержащее данные обмена
	//Сообщение = Новый COMОбъект("MSMQ.MSMQMessage");
	//Сообщение.Label = ИмяФайлаСообщения;
	//Сообщение.Body = ДанныеОбмена.Прочитать();
	//Сообщение.ResponseQueueInfo = qinfo;
	//
	//// Помещаем сообщение в очередь
	//Сообщение.Send(Очередь);
	//
	//Сообщить(" - Помещен файл " + ИмяФайлаСообщения + " в очередь " + ОчередьОбменаMSMQ);
	//
	//Очередь.Close();
	//ДанныеОбмена.Закрыть();
	
КонецПроцедуры

// Функция получения файла с новым сообщением обмена из очереди
// Выбирает из очереди сообщение обмена и сохраняет в файле
//
// Параметры:
//  ИмяФайла - файл, в который будет произведено копирование файла с сообщением обмена
//
// Возвращаемое значение:
//  Булево - Истина - если файл с сообщением обмена получен и Ложь - в противном случае
//
Функция ПолучитьФайлОбменаИЗОчереди(ИмяФайла)
	
	//// Флаги
	//MQ_DENY_NONE = 0;
	//MQ_RECEIVE_ACCESS = 1;
	//MQ_NO_TRANSACTION = 0;

	//qinfo = Новый COMОбъект("MSMQ.MSMQQueueInfo");
	//
	//// Находим позицую начала имени очереди в АдресОбменаMSMQ
	//Индекс = СтрДлина(ОчередьОбменаMSMQ);
	//Пока (Индекс <> 0) Цикл
	//	
	//	Если Сред(ОчередьОбменаMSMQ, Индекс, 1) = "\" Тогда
	//		Прервать;
	//	КонецЕсли;
	//	
	//	Индекс = Индекс - 1;
	//	
	//КонецЦикла;
	//
	//// Собираем путь к очереди для чтения данных обмена
	//qinfo.PathName = ".\" + Прав(ОчередьОбменаMSMQ, СтрДлина(ОчередьОбменаMSMQ) - Индекс) + 
	//				 "_" + СокрП(ПланыОбмена.СинхронизацияНоменклатуры.ЭтотУзел().Код);
	//				 
	//Попытка
	//	
	//	qinfo.Create();
	//	
	//Исключение
	//КонецПопытки;
	//
	//// Открываем очередь
	//Очередь = qinfo.Open(MQ_RECEIVE_ACCESS, MQ_DENY_NONE);
	//
	//// Временный объект необходим для поиска последнего сообщения
	//СообщениеВрем = Новый COMОбъект("MSMQ.MSMQMessage");
	//// Читаем первое сообщение
	//СообщениеВрем = Очередь.Receive(MQ_NO_TRANSACTION, , , 0);
	//
	//Пока (СообщениеВрем <> Неопределено) Цикл
	//	
	//	Сообщение = СообщениеВрем;
	//	// Читаем последующие сообщения, если они присутствуют
	//	СообщениеВрем = Очередь.Receive(MQ_NO_TRANSACTION, , , 0);
	//	
	//КонецЦикла;
	//
	//// Закрываем очередь
	//Очередь.Close();
	//
	//// Если получили сообщение, разбираем его и передаем данные обмена 
	//// дальше для обработки
	//Если Сообщение <> Неопределено Тогда
	//	
	//	ИмяФайлаСообщения = Сообщение.Label;
	//	ФайлОбмена = Новый ЗаписьТекста(ИмяФайла);
	//	ФайлОбмена.Записать(Сообщение.Body);
	//	ФайлОбмена.Закрыть();
	//	
	//	Сообщить(" - Принят файл обмена данными " + ИмяФайлаСообщения + " из очереди " + ОчередьОбменаMSMQ);
	//	Возврат Истина;
	//	
	//Иначе
	//	
	//	Возврат Ложь;
	//
	//КонецЕсли;
	
КонецФункции

// Процедура размещения сообщения обмена в очереди IBM WebSphere MQ
//
// Параметры:
//  ИмяФайла 		- имя файла, содержащего сообщение обмена
//  НомерСообщения  - номер сообщения отправляемых данных
//
Процедура ПоместитьДанныеОбменаВОчередьWSMQ(ИмяФайла, НомерСообщения)
	
	//// Определяем флаг
	//MQOO_OUTPUT = 16;
	//
	//Попытка
	//	
	//	// Подключаемся к менеджеру очереди
	//	Сессия = Новый COMОбъект("MQAX200.MQSession");
	//	МенеджерОчереди = Сессия.AccessQueueManager("");     
	//	
	//Исключение
	//	
	//	Сообщить(" - Ошибка доступа к очереди: " + ОписаниеОшибки());
	//	Возврат;
	//	
	//КонецПопытки;
	//
	//Попытка
	//	
	//	// Открываем очередь на запись
	//	Очередь = МенеджерОчереди.AccessQueue(УдаленнаяОчередь, MQOO_OUTPUT);
	//	
	//Исключение
	//	
	//	Сообщить(" - Ошибка открытия очереди: " + ОписаниеОшибки());
	//	Возврат;
	//	
	//КонецПопытки;
	//
	//Попытка
	//	
	//	// Создаем новое сообщение
	//	Сообщение = Сессия.AccessMessage();
	//	
	//	// Открываем файл с данными обмена
	//	ДанныеОбмена = Новый ЧтениеТекста;
	//	ДанныеОбмена.Открыть(ИмяФайла);
	//	
	//	// Считываем данные из файла в сообщение, которое затем помещается в очередь
	//	Сообщение.writeString(ДанныеОбмена.Прочитать());
	//	// Помещаем сообщение в очередь
	//	Очередь.Put(Сообщение);
	//	
	//Исключение
	//	
	//	Сообщить(" - Ошибка размещения сообщения в очереди: " + ОписаниеОшибки());
	//	Возврат;
	//	
	//КонецПопытки;
	//
	//Сообщить(" - Помещен файл в очередь " + УдаленнаяОчередь);

	//ДанныеОбмена.Закрыть();
	
КонецПроцедуры

// Функция получения файла с новым сообщением обмена из очереди IBM WebSphere MQ
// Выбирает из очереди сообщение обмена и сохраняет в файле
//
// Параметры:
//  ИмяФайла - файл, в который будет произведено копирование файла с сообщением обмена
//
// Возвращаемое значение:
//  Булево - Истина - если файл с сообщением обмена получен и Ложь - в противном случае
//
Функция ПолучитьФайлОбменаИЗОчередиWSMQ(ИмяФайла)
	
	//// Определяем флаг
	//MQOO_INPUT_AS_Q_DEF = 1;
	//
	//Попытка
	//	
	//	// Подключаемся к менеджеру очереди
	//	Сессия = Новый COMОбъект("MQAX200.MQSession");
	//	МенеджерОчереди = Сессия.AccessQueueManager("");     
	//	
	//Исключение
	//	
	//	Сообщить(" - Ошибка доступа к очереди: " + ОписаниеОшибки());
	//	Возврат Ложь;
	//	
	//КонецПопытки;
	//
	//// Открываем очередь для чтения из неё данных обмена
	//Попытка
	//	
	//	Очередь = МенеджерОчереди.AccessQueue(ЛокальнаяОчередь, MQOO_INPUT_AS_Q_DEF);
	//	
	//Исключение
	//	
	//	Сообщить(" - Ошибка открытия очереди: " + ОписаниеОшибки());
	//	Возврат Ложь;
	//	
	//КонецПопытки;
	//
	//Попытка
	//	
	//	// Создаем сообщение
	//	Сообщение = Сессия.AccessMessage();
	//	// получаем сообщение
	//	Очередь.Get(Сообщение);
	//	
	//Исключение
	//	
	//	Сообщить(" - Ошибка чтения данных из очереди: " + ОписаниеОшибки());
	//	Возврат Ложь;
	//	
	//КонецПопытки;

	//// Читаем из сообщения данные обмена и сохраняем их в файл
	//Данные = Сообщение.ReadString(Сообщение.MessageLength);
	//
	//ФайлОбмена = Новый ЗаписьТекста(ИмяФайла);
	//ФайлОбмена.Записать(Данные);
	//ФайлОбмена.Закрыть();
	//
	//Сообщить(" - Принят файл обмена данными из очереди " + ЛокальнаяОчередь);
	//
	//Возврат Истина;
		
КонецФункции
