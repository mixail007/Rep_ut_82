////////////////////////////////////////////////////////////////////////////////
// ПЕРЕМЕННЫЕ МОДУЛЯ

Перем мРегистрБухгалтерии; // регистр бухгалтерии, итоги которого отображаются в Табло.

////////////////////////////////////////////////////////////////////////////////
// ОБРАБОТЧИКИ СОБЫТИЙ

// Обработчик события ПриОткрытии формы.
//
Процедура ПриОткрытии()

	РассчитатьИтогиДляТабло();

КонецПроцедуры

// Обработчик события Нажатие элемента ДействиеОбновить командной панели ВерхняяКоманднаяПанель.
//
Процедура ВерхняяКоманднаяПанельДействиеОбновить(Кнопка)

	РассчитатьИтогиДляТабло();

КонецПроцедуры

// Обработчик события Нажатие кнопки КнопкаВыборПериода.
//
Процедура КнопкаВыборПериодаНажатие(Элемент)

	НастройкаПериода = Новый НастройкаПериода;

	НастройкаПериода.УстановитьПериод(НачалоПериода, КонецДняПериода());
	НастройкаПериода.РедактироватьКакИнтервал = Истина;
	НастройкаПериода.РедактироватьКакПериод   = Истина;
	НастройкаПериода.ВариантНастройки         = ВариантНастройкиПериода.Период;

	НастройкаПериода.Редактировать();

	НачалоПериода = НастройкаПериода.ПолучитьДатуНачала();
	КонецПериода  = НастройкаПериода.ПолучитьДатуОкончания();
	
	РассчитатьИтогиДляТабло();

КонецПроцедуры

// Обработчик события ПриНачалеРедактирования табличного поля Табло.
//
Процедура ТаблоПриНачалеРедактирования(Элемент, НоваяСтрока)

	НазначитьТипыДоступностьСубконто(Элемент.ТекущиеДанные);

	Если ЗначениеНеЗаполнено(Организация) Тогда
		Возврат;
	КонецЕсли;

	Элемент.ТекущиеДанные.Организация = Организация;

КонецПроцедуры

// Обработчик события ПриОкончанииРедактирования табличного поля Табло.
//
Процедура ТаблоПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)

	Если НЕ ОтменаРедактирования И Элемент.ТекущаяСтрока <> Неопределено Тогда
		
		РассчитатьИтогиДляТабло();
		
		ЗаполнитьСтрокуТабло(Элемент.ТекущиеДанные);
		
	КонецЕсли;

КонецПроцедуры

// Обработчик события ПриИзменении поля ввода Счет табличного поля Табло.
//
Процедура ТаблоСчетПриИзменении(Элемент)

	НазначитьТипыДоступностьСубконто(ЭлементыФормы.Табло.ТекущиеДанные);
	ТаблоПриАктивизацииСтроки(ЭлементыФормы.Табло);

КонецПроцедуры

// Обработчик события ПриАктивизииСтроки табличного поля Табло.
//
Процедура ТаблоПриАктивизацииСтроки(Элемент)

	Элементы = Элемент.Колонки;
	Данные   = Элемент.ТекущиеДанные;

	Если Данные = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Элементы.Валюта.Доступность    = Данные.Счет.Валютный;
	Элементы.Субконто1.Доступность = ?(Данные.Счет.ВидыСубконто.Количество() > 0, Истина, Ложь);
	Элементы.Субконто2.Доступность = ?(Данные.Счет.ВидыСубконто.Количество() > 1, Истина, Ложь);
	Элементы.Субконто3.Доступность = ?(Данные.Счет.ВидыСубконто.Количество() > 2, Истина, Ложь);

КонецПроцедуры

// Обработчик события ПриИзменении поля ввода НачалоПериода.
//
// Вызывает обновление данных в табличной части.
//
Процедура НачалоПериодаПриИзменении(Элемент)
	
	РассчитатьИтогиДляТабло();
	
КонецПроцедуры // НачалоПериодаПриИзменении()

// Обработчик события ПриИзменении поля ввода КонецПериода.
//
// Вызывает обновление данных в табличной части.
//
Процедура КонецПериодаПриИзменении(Элемент)
	
	РассчитатьИтогиДляТабло();
	
КонецПроцедуры // КонецПериодаПриИзменении()

// Обработчик события ПриИзменении поля ввода Организация.
//
// Вызывает обновление данных в табличной части.
//
Процедура ОрганизацияПриИзменении(Элемент)
	
	РассчитатьИтогиДляТабло();
	
КонецПроцедуры // КонецПериодаПриИзменении()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ, ВЫЗЫВАЕМЫЕ ИЗ ОБРАБОТЧИКОВ СОБЫТИЙ

// Процедура расситывает бухгалтерские итоги и выводит их в строки Табло.
//
// Параметры:
//  Нет.
//
Процедура РассчитатьИтогиДляТабло()

	// Структура группировок описывает, в каких разрезах требуется расчет итогов.
	СтруктураГруппировок = Новый Структура();

	// Для строки Табло расччитываются итоги в разрезе счетов.
	СтруктураГруппировок.Вставить("Счет");

	// Для строки Табло расччитываются итоги в разрезе всех измерений.
	Для каждого Измерение Из мРегистрБухгалтерии.Измерения Цикл
		СтруктураГруппировок.Вставить(Измерение.Имя);
	КонецЦикла;

	// Для расчета итогов вызывается процедура модуля обработки БухгалтерскиеИтоги.
	РассчитатьИтоги(мРегистрБухгалтерии, , , СтруктураГруппировок, НачалоПериода, КонецДняПериода(), , , , , , "Организация", Организация);

	// Перебираются строки Табло и заполняются бухгалтерские итоги.
	Для каждого СтрокаТабло Из Табло Цикл
		ЗаполнитьСтрокуТабло(СтрокаТабло);
	КонецЦикла;

КонецПроцедуры

// Процедура получает рассчитанные бухгалтерские итоги и выводит их в строку Табло.
//
// Параметры:
//  СтрокаТабло - строка таблицы значений Табло, в которую вывести итоги.
//
Процедура ЗаполнитьСтрокуТабло(СтрокаТабло)

	// Структура группировок описывает, в каких разрезах требуется получение итогов.
	СтруктураГруппировок = Новый Структура();

	// Для строки Табло получаются итоги по счету - в обязательном порядке.
	СтруктураГруппировок.Вставить("Счет", СтрокаТабло.Счет);

	// Для строки Табло получаются итоги в разрезе всех измерений, которые заданы 
	// (имеют непустые значения) в ячейках данной строки.
	Для каждого Измерение Из мРегистрБухгалтерии.Измерения Цикл
		ЗначениеГруппировки = СтрокаТабло[Измерение.Имя];
		// Если значение группировки не задано, группировка игнорируется при получении итогов.
		Если ЗначениеГруппировки <> Неопределено И НЕ ЗначениеГруппировки.Пустая() Тогда
			СтруктураГруппировок.Вставить(Измерение.Имя, ЗначениеГруппировки);
		КонецЕсли;
	КонецЦикла;

	ИтогиПоСубконто = Ложь;

	// Для строки Табло получаются итоги в разрезе всех субконто, которые заданы 
	// (имеют непустые значения) в ячейках данной строки.
	Для Номер = 1 По мРегистрБухгалтерии.ПланСчетов.МаксКоличествоСубконто Цикл
		ЗначениеГруппировки = СтрокаТабло["Субконто" + Номер];
		// Если значение группировки не задано, группировка игнорируется при получении итогов.
		Если ЗначениеГруппировки <> Неопределено И НЕ ЗначениеГруппировки.Пустая() Тогда
			СтруктураГруппировок.Вставить("Субконто" + Номер, ЗначениеГруппировки);

			ИтогиПоСубконто = Истина;
		КонецЕсли;
	КонецЦикла;

	Если ИтогиПоСубконто Тогда
		// Итоги по субкотно формируются без использования предварительного расчета.
		ЗаполнитьИтогиПоСубконто(СтрокаТабло, СтруктураГруппировок);
	Иначе
		// Итоги без субкотно формируются с использованием предварительного расчета.
		ЗаполнитьИтогиБезСубконто(СтрокаТабло, СтруктураГруппировок);
	КонецЕсли;

КонецПроцедуры

// Процедура выводит итоги в строке табло без использования предварительного расчета..
//
// Параметры:
//  СтрокаТабло          - строка таблицы значений Табло, в которую вывести итоги.
//  СтруктураГруппировок - Структура - имена и значения группировок, по которым надо получать итоги.
//                         Имя группировки указывается в качестве ключа, а значение - 
//                         в качестве значения элемента структуры.
//
Процедура ЗаполнитьИтогиПоСубконто(СтрокаТабло, СтруктураГруппировок)

	Перем Счет;

	// Счет передается отдельным параметром.
	Если СтруктураГруппировок.Свойство("Счет", Счет) Тогда
		СтруктураГруппировок.Удалить("Счет");
	КонецЕсли;

	Для каждого Ресурс Из мРегистрБухгалтерии.Ресурсы Цикл

		Если НЕ Счет.Валютный И Ресурс.Имя = "ВалютнаяСумма" Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ Счет.Количественный И Найти(Ресурс.Имя, "Количество") > 0 Тогда
			Продолжить;
		КонецЕсли;

		Если НачалоПериода <> '00010101' Тогда
			СтрокаТабло[Ресурс.Имя + "НачальныйОстатокДт"] = Остаток(мРегистрБухгалтерии, Ресурс.Имя, "Дт", НачалоПериода, Счет, , СтруктураГруппировок);
			СтрокаТабло[Ресурс.Имя + "НачальныйОстатокКт"] = Остаток(мРегистрБухгалтерии, Ресурс.Имя, "Кт", НачалоПериода, Счет, , СтруктураГруппировок);
		Иначе
			СтрокаТабло[Ресурс.Имя + "НачальныйОстатокДт"] = 0;
			СтрокаТабло[Ресурс.Имя + "НачальныйОстатокКт"] = 0;
		КонецЕсли;

		СтрокаТабло[Ресурс.Имя + "ОборотДт"]          = Оборот (мРегистрБухгалтерии, Ресурс.Имя, "Дт", НачалоПериода, КонецДняПериода(), Счет, , , , СтруктураГруппировок);
		СтрокаТабло[Ресурс.Имя + "ОборотКт"]          = Оборот (мРегистрБухгалтерии, Ресурс.Имя, "Кт", НачалоПериода, КонецДняПериода(), Счет, , , , СтруктураГруппировок);

		СтрокаТабло[Ресурс.Имя + "КонечныйОстатокДт"] = Остаток(мРегистрБухгалтерии, Ресурс.Имя, "Дт", КонецДняПериода(), Счет, , СтруктураГруппировок);
		СтрокаТабло[Ресурс.Имя + "КонечныйОстатокКт"] = Остаток(мРегистрБухгалтерии, Ресурс.Имя, "Кт", КонецДняПериода(), Счет, , СтруктураГруппировок);
	КонецЦикла;

КонецПроцедуры

// Процедура выводит итоги в строке табло c использованием предварительного расчета..
//
// Параметры:
// Параметры:
//  СтрокаТабло          - строка таблицы значений Табло, в которую вывести итоги.
//  СтруктураГруппировок - Структура - имена и значения группировок, по которым надо получать итоги.
//                         Имя группировки указывается в качестве ключа, а значение - 
//                         в качестве значения элемента структуры.
//
Процедура ЗаполнитьИтогиБезСубконто(СтрокаТабло, СтруктураГруппировок)

	// Функция модуля обработки БухгалтерскиеИтоги возвращает
	// выборку, если итоги по группировкам существуют, или Неопределено.
	Итоги = ПолучитьОстаткиИОбороты(СтруктураГруппировок);

	Для каждого Ресурс Из мРегистрБухгалтерии.Ресурсы Цикл
		Если ТипЗнч(Итоги) = Тип("ВыборкаИзРезультатаЗапроса") ИЛИ ТипЗнч(Итоги) = Тип("Структура") Тогда
			СтрокаТабло[Ресурс.Имя + "НачальныйОстатокДт"] = Итоги[Ресурс.Имя + "НачальныйОстатокДт"];
			СтрокаТабло[Ресурс.Имя + "НачальныйОстатокКт"] = Итоги[Ресурс.Имя + "НачальныйОстатокКт"];

			СтрокаТабло[Ресурс.Имя + "ОборотДт"          ] = Итоги[Ресурс.Имя + "ОборотДт"          ];
			СтрокаТабло[Ресурс.Имя + "ОборотКт"          ] = Итоги[Ресурс.Имя + "ОборотКт"          ];

			СтрокаТабло[Ресурс.Имя + "КонечныйОстатокДт" ] = Итоги[Ресурс.Имя + "КонечныйОстатокДт" ];
			СтрокаТабло[Ресурс.Имя + "КонечныйОстатокКт" ] = Итоги[Ресурс.Имя + "КонечныйОстатокКт" ];
		Иначе
			СтрокаТабло[Ресурс.Имя + "НачальныйОстатокДт"] = 0;
			СтрокаТабло[Ресурс.Имя + "НачальныйОстатокКт"] = 0;

			СтрокаТабло[Ресурс.Имя + "ОборотДт"          ] = 0;
			СтрокаТабло[Ресурс.Имя + "ОборотКт"          ] = 0;

			СтрокаТабло[Ресурс.Имя + "КонечныйОстатокДт" ] = 0;
			СтрокаТабло[Ресурс.Имя + "КонечныйОстатокКт" ] = 0;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Процедура управляет типом и доступностью субконто в строке Табло.
// Тип и доступность субконто зависят от счета.
//
// Параметры:
//  СтрокаТабло - строка таблицы значений Табло, в которой надо назначить 
// тип и доступность субконто.
//
Процедура НазначитьТипыДоступностьСубконто(СтрокаТабло)

	// Обрабатываются субконто строки Табло, определенные для счета, указанного в строке.
	Для Номер = 1 По СтрокаТабло.Счет.ВидыСубконто.Количество() Цикл
		ОписаниеТиповСубконто = СтрокаТабло.Счет.ВидыСубконто[Номер - 1].ВидСубконто.ТипЗначения;
		// Значения субконто в строке Табло приводятся к типам видов субконто счета.
		СтрокаТабло["Субконто" + Номер] = ОписаниеТиповСубконто.ПривестиЗначение(СтрокаТабло["Субконто" + Номер]);
	КонецЦикла;

	// Обрабатываются субконто строки Табло, не определенные для счета, указанного в строке.
	Для Номер = Номер По мРегистрБухгалтерии.ПланСчетов.МаксКоличествоСубконто Цикл
		// Значения субконто в строке Табло очищаются.
		СтрокаТабло["Субконто" + Номер] = Неопределено;
	КонецЦикла;

КонецПроцедуры

// Функция вычисляет конец дня периода расчета итогов.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Дата - конец дня периода расчета итогов.
//
Функция КонецДняПериода()

	Если КонецПериода <> '00010101' Тогда
		Возврат КонецДня(КонецПериода);
	Иначе
		Возврат КонецПериода;
	КонецЕсли;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ОПЕРАТОРЫ МОДУЛЯ

мРегистрБухгалтерии = Метаданные.РегистрыБухгалтерии.Хозрасчетный;
