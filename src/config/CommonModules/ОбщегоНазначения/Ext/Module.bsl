
// Функция преобразует строку к множественному числу
//
// Параметры: 
//  Слово1 - форма слова в ед числе      ("шкаф")
//  Слово2 - форма слова для числит 2-4  ("шкафа")
//  Слово3 - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - целое число
//
// Возвращаемое значение:
//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
//
// Описание:
//  Предназначена для формирования "правильной" подписи к числительным
//
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, ЦелоеЧисло) Экспорт

	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ВАЛЮТАМИ

// Эта функция пересчитывает сумму из валюты ВалютаНач по курсу ПоКурсуНач 
// в валюту ВалютаКон по курсу ПоКурсуКон
//
// Параметры:      
//	Сумма          - сумма, которую следует пересчитать;
//	ВалютаНач      - ссылка на элемент справочника Валют;
//                   определяет валюты из которой надо пересчитвать;
//	ВалютаКон      - ссылка на элемент справочника Валют;
//                   определяет валюты в которую надо пересчитвать;
// 	ПоКурсуНач     - курс из которого надо пересчитать;
// 	ПоКурсуКон     - курс в который надо пересчитать;
// 	ПоКратностьНач - кратность из которого надо пересчитать (по умолчанию = 1);
// 	ПоКратностьКон - кратность в который надо пересчитать  (по умолчанию = 1);
//
// Возвращаемое значение: 
//  Сумма, пересчитанная в другую валюту
//
Функция ПересчитатьИзВалютыВВалюту(Сумма, ВалютаНач, ВалютаКон, ПоКурсуНач, ПоКурсуКон, 
	               ПоКратностьНач =1, ПоКратностьКон = 1 ) Экспорт

	Если (ВалютаНач = ВалютаКон) Тогда

		// Считаем, что пересчет не нужен.
		Возврат Сумма;
	КонецЕсли;

	Если (ПоКурсуНач = ПоКурсуКон) 
	   и (ПоКратностьНач = ПоКратностьКон) Тогда

		// ну, тут и считать нечего...
		Возврат Сумма;
	КонецЕсли;

	Если ПоКурсуНач     = 0 
	 или ПоКурсуКон     = 0 
	 или ПоКратностьНач = 0 
	 или ПоКратностьКон = 0 Тогда
		СообщитьОбОшибке("ПересчитатьИзВалютыВВалюту(): при пересчете обнаружен нулевой курс.");
		Возврат 0;
	КонецЕсли;

	Возврат Окр((Сумма * ПоКурсуНач * ПоКратностьКон) / (ПоКурсуКон * ПоКратностьНач), 2);

КонецФункции //ПересчитатьИзВалютыВВалюту()

// Возвращает курс валюты на дату
//
// Параметры:
//  Валюта     - Валюта (элемент справочника "Валюты")
//  ДатаКурса  - Дата, на которую следует получить курс
//
// Возвращаемое значение: 
//  Структура, содержащая:
//   Курс      - курс валюты
//   Кратность - кратность валюты
//
Функция ПолучитьКурсВалюты(Валюта, ДатаКурса) Экспорт

	Структура = РегистрыСведений.КурсыВалют.ПолучитьПоследнее(ДатаКурса, Новый Структура("Валюта", Валюта));
	Возврат Структура;
	
КонецФункции // ПолучитьКурсВалюты()

// Проверяет наличие установленного курс аи кратности валюты на 1 января 1980 года.
// В случае отсутствия устанавливает курс и кратность равными единице.
//
// Параметры:
//  Валюта - ссылка на элемент справочника Валют
//
Процедура ПроверитьКорректностьКурсаНа01_01_1980(Валюта) Экспорт

	ДатаКурса = Дата(1980, 1, 1);
	СтруктураКурса = ПолучитьКурсВалюты(Валюта, ДатаКурса);

	Если (СтруктураКурса.Курс = 0) Или (СтруктураКурса.Кратность = 0) Тогда

		// установим курс и кратность = 1 на 01.01.1980, чтобы не было ошибок при создании документов

		РегистрКурсыВалют = РегистрыСведений.КурсыВалют.СоздатьМенеджерЗаписи();

		РегистрКурсыВалют.Период    = ДатаКурса;
		РегистрКурсыВалют.Валюта    = Валюта;
		РегистрКурсыВалют.Курс      = 1;
		РегистрКурсыВалют.Кратность = 1;
		РегистрКурсыВалют.Записать();

	КонецЕсли;

КонецПроцедуры // ПроверитьКорректностьКурсаНа01_01_1980()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ

// Определяет заполнено ли переданное значение
//
// Параметры: 
//  Значение - значение, заполенение которого надо проверить
//
// Возвращаемое значение:
//  Истина - значение не заполнено, ложь - иначе.
//
Функция ЗначениеНеЗаполнено(Значение) Экспорт

	//Возврат НЕ ЗначениеЗаполнено(Значение); // +++ 25.05.2012 - функция платформы - быстрее
	
	Результат = Ложь;
	ТипЗначения = ТипЗнч(Значение);

	// Сначала примитивные типы
	Если Значение = Неопределено Тогда
		Результат = Истина;
	ИначеЕсли Значение = NULL Тогда
		Результат = Истина;
	ИначеЕсли ТипЗначения = Тип("Строка") Тогда
		Если СокрЛП(Значение) = "" Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Число") Тогда
		Если Значение = 0 Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		Если Значение = Дата('00010101') Тогда
			Результат = Истина;
		КонецЕсли; 
	ИначеЕсли ТипЗначения = Тип("Булево") Тогда
		Результат = Ложь; // Булево будем считать не пустым
		
	//Отдельное определение, так как конструкторов данного типа не существует	
	ИначеЕсли ТипЗначения = Тип("РежимПроведенияДокумента") Тогда
		Если Значение = РежимПроведенияДокумента.Неоперативный или Значение = РежимПроведенияДокумента.Оперативный тогда
			Результат = Ложь;
		КонецЕсли;
		
	// Для остальных будем считать значение пустым, если оно равно
	// дефолтному значению своего типа
	Иначе
		Попытка
			Если Значение = Новый(ТипЗначения) Тогда
				Результат = Истина;
			КонецЕсли; 
		Исключение
			Результат = Ложь;
		КонецПопытки;

	КонецЕсли; 

	Возврат Результат;
	
КонецФункции // ЗначениеНеЗаполнено()

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	Иначе
		Возврат Новый (ЗаданныйТип);
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли табличная часть документа с переданным именем.
//
// Параметры: 
//  ИмяТабЧасти - строковое имя искомой табличной части,
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьТабЧастьДокумента(ИмяТабЧасти, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьТабЧастьДокумента()

// Позволяет определить есть ли среди реквизитов шапки отчета
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита     - строковое имя искомого реквизита, 
//  МетаданныеОтчета - метаданные отчета, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитОтчета(ИмяРеквизита, МетаданныеОтчета) Экспорт

	Если МетаданныеОтчета.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьРеквизитОтчета()

// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
	Если ТабЧасть = Неопределено Тогда // Нет такой таб. части в документе
		Возврат Ложь;
	Иначе
		Если ТабЧасть.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
			Возврат Ложь;
		Иначе
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;

КонецФункции // ЕстьРеквизитТабЧастиДокумента()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт

	СписокКодовЧисел = Новый СписокЗначений;
	Для а = 48 По 57 Цикл
		СписокКодовЧисел.Добавить(а);
	КонецЦикла; 
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		
		Возврат Истина;
		
	Иначе
		
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			Если СписокКодовЧисел.НайтиПоЗначению(КодСимвола(Сред(СтрокаПроверки, а, 1))) = Неопределено Тогда
				Возврат Истина;
			КонецЕсли; 
		КонецЦикла; 
		
	КонецЕсли; 

	Возврат Ложь;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт
	
	Массив = Новый Массив; 
	Массив.Добавить(Тип("Строка"));
	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);
	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);
	
КонецФункции // ПолучитьОписаниеТиповСтроки()	 

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность,РазрядностьДробнойЧасти=0) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Число"));
	КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность,РазрядностьДробнойЧасти);
	Возврат Новый ОписаниеТипов(Массив, КвалификаторЧисла);
	
КонецФункции	// ПолучитьОписаниеТиповЧисла() 

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));
	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);
	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);
	
КонецФункции	// ПолучитьОписаниеТиповДаты() 

// Служебная функция - возвращает принадлежность объекта метаданных определенному классу
// 
// Параметры:
//	Класс  - класс
//	Объект - объект метаданных
// 
Функция ПринадлежностьКлассуМетаданных(Класс, Объект) Экспорт
	Для Каждого МДОбъект Из Метаданные[Класс] Цикл
		Если МДОбъект = Объект Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции // ПринадлежностьКлассуМетаданных()

// Служебная функция, предназначенная для получения описания типов набора записей по объекту метаданных
// Параметры:
//	Объект - объект метаданных
//
// Возвращаемое значение:
// Описание типов с единственным типом набора записей
//
Функция ПолучитьОписаниеТиповНабораЗаписей(Объект) Экспорт
	
	Массив = Новый Массив;
	Если ПринадлежностьКлассуМетаданных("РегистрыРасчета", Объект) Тогда
		Массив.Добавить(Тип("РегистрРасчетаНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыБухгалтерии", Объект) Тогда
		Массив.Добавить(Тип("РегистрБухгалтерииНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыНакопления", Объект) Тогда
		Массив.Добавить(Тип("РегистрНакопленияНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыСведений", Объект) Тогда
		Массив.Добавить(Тип("РегистрСведенийНаборЗаписей."+Объект.Имя));
	КонецЕсли;
	Возврат Новый ОписаниеТипов(Массив);
	
КонецФункции  // ПолучитьОписаниеТиповНабораЗаписей()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ

// Сравнивает два массива однотипных значений (кроме коллекций значений)
//
// Параметры: 
//  ПервыйМассив,ВторойМассив - сравниваемые массивы
//
// Возвращаемое значение:
//  булево.
//
Функция МассивыИдентичны(ПервыйМассив,ВторойМассив) Экспорт

    ЭлементовМассива = ПервыйМассив.Количество();
	МассивыСовпадают = (ЭлементовМассива = ВторойМассив.Количество()); 
	  
	Если МассивыСовпадают Тогда
		Для Сч = 1 По ЭлементовМассива Цикл
			Если ПервыйМассив[Сч-1] <> ВторойМассив[Сч-1] Тогда
				Возврат Ложь
			КонецЕсли;
		КонецЦикла; 		
	КонецЕсли;

	Возврат МассивыСовпадают

КонецФункции // МассивыИдентичны()

////////////////////////////////////////////////////////////////////////////////
//  ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УНИВЕРСАЛЬНЫМИ КОЛЛЕКЦИЯМИ ЗНАЧЕНИЙ

// Создает копию переданного массива, структуры или соответствия
//
// Параметры:
//  КоллекцияИсходная: тип Массив, Структура, Соответствие - исходная коллекция
// Возвращаемое значение:
//  КоллекцияКопия:  тип Массив, Структура, Соответствие - копия исходной коллекции
//
Функция СкопироватьУниверсальнуюКоллекцию(КоллекцияИсходная) Экспорт
	
	Если ТипЗнч(КоллекцияИсходная)=Тип("Массив") Тогда
		
		КоллекцияКопия=Новый Массив;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Добавить(Элемент);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Структура") Тогда
		
		КоллекцияКопия=Новый Структура;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия; 
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Соответствие") Тогда
		
		КоллекцияКопия=Новый Соответствие;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	Иначе
		
		Сообщить("Неверный тип универсальной коллекции для копирования");
		Возврат Неопределено
		
	КонецЕсли;
	
КонецФункции // СкопироватьУниверсальнуюКоллекцию()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//
Процедура СообщитьОбОшибке(ТекстСообщения, Отказ = Ложь, Заголовок = "", ПарамПереноса = "") Экспорт

	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	Если ОкончаниеСлужебногоСообщения > 0 И Лев(ТекстСообщения, 1) = "{" Тогда
		ТекстСообщения = СокрЛП(Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2)));
	КонецЕсли;
	
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		Если НЕ ЗначениеНеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#Иначе
		
		Если НЕ ЗначениеНеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
		Сообщить(ТекстСообщения, СтатусСообщения.Важное);
		
	#КонецЕсли
	
	//***20150708
	#Если не Клиент Тогда 
		Если НЕ ПараметрыСеанса.ПроведениеПоПартиямОшибкиРеглЗадания = "" Тогда
			ПараметрыСеанса.ПроведениеПоПартиямОшибкиРеглЗадания = ПараметрыСеанса.ПроведениеПоПартиямОшибкиРеглЗадания + Символы.ПС + ТекстСообщения;
		КонецЕсли;     
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

//ИЗ 10.3
// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
//  Параметры
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                - Любая ссылка на объект информационной базы.
//                               Ссылка на объект информационной базы, к которому это сообщение относится,
//                               или ключ записи.
//  Поле                       - Строка - наименование реквизита формы
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы)
//  Отказ                      - Булево - Выходной параметр
//                               Всегда устанавливается в значение Истина
//
//	Примеры использования:
//
//	1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ПолеВРеквизитеФормыОбъект",
//		"Объект");
//
//	Альтернативный вариант использования в форме объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"Объект.ПолеВРеквизитеФормыОбъект");
//
//	2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ИмяРеквизитаФормы");
//
//	3. Для вывода сообщения связанного с объектом информационной базы
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
// 4. Для вывода сообщения по ссылке на объект информационной базы
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
// Случаи некорректного использования:
//  1. Передача одновременно параметров КлючДанных и ПутьКДанным
//  2. Передача в параметре КлючДанных значения типа отличного от допустимых
//  3. Установка ссылки без установки поля (и/или пути к данным)
//
Процедура СообщитьПользователю(
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
#Если НЕ (ТонкийКлиент ИЛИ ВебКлиент) Тогда
	Если КлючДанных <> Неопределено
	   И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = Найти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
#КонецЕсли
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура СообщитьИнформациюПользователю(СтрокаСообщенияПользователю) Экспорт
	
	#Если Клиент Тогда
	Сообщить(СтрокаСообщенияПользователю);
	#КонецЕсли
	
КонецПроцедуры
// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[ИмяРеквизита];
	
КонецФункции 
// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка    - Ссылка на объект - элемент справочника, документ, ...
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		
		СтруктураРеквизитов = Новый Структура(Реквизиты);
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Структура")
	      ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		
		СтруктураРеквизитов = Реквизиты;
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив")
	      ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		
		СтруктураРеквизитов = Новый Структура;
		Для каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"),
			Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Ключ));
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции
// Подставляет параметры в строку. Максимально возможное число параметров - 9.
// Параметры в строке задаются как %<номер параметра>. Нумерация параметров начинается с единицы.
//
// Параметры:
//  СтрокаПодстановки  – Строка – шаблон строки с параметрами (вхождениями вида "%ИмяПараметра");
//  Параметр<n>        - Строка - подставляемый параметр.
//
// Возвращаемое значение:
//  Строка   – текстовая строка с подставленными параметрами.
//
// Пример:
//  ПодставитьПараметрыВСтроку(НСтр("ru='%1 пошел в %2'"), "Вася", "Зоопарк") = "Вася пошел в Зоопарк".
//
Функция ПодставитьПараметрыВСтроку(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено) Экспорт
	
	ИспользоватьАльтернативныйАлгоритм = 
		Найти(Параметр1, "%")
		Или Найти(Параметр2, "%")
		Или Найти(Параметр3, "%")
		Или Найти(Параметр4, "%")
		Или Найти(Параметр5, "%")
		Или Найти(Параметр6, "%")
		Или Найти(Параметр7, "%")
		Или Найти(Параметр8, "%")
		Или Найти(Параметр9, "%");
		
	Если ИспользоватьАльтернативныйАлгоритм Тогда
		СтрокаПодстановки = ПодставитьПараметрыВСтрокуАльтернативныйАлгоритм(СтрокаПодстановки, Параметр1,
			Параметр2, Параметр3, Параметр4, Параметр5, Параметр6, Параметр7, Параметр8, Параметр9);
	Иначе
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%1", Параметр1);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%2", Параметр2);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%3", Параметр3);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%4", Параметр4);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%5", Параметр5);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%6", Параметр6);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%7", Параметр7);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%8", Параметр8);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%9", Параметр9);
	КонецЕсли;
	
	Возврат СтрокаПодстановки;
КонецФункции
// Вставляет параметры в строку, учитывая, что в параметрах могут использоваться подстановочные слова %1, %2 и т.д.
Функция ПодставитьПараметрыВСтрокуАльтернативныйАлгоритм(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено)
	
	Результат = "";
	Позиция = Найти(СтрокаПодстановки, "%");
	Пока Позиция > 0 Цикл 
		Результат = Результат + Лев(СтрокаПодстановки, Позиция - 1);
		СимволПослеПроцента = Сред(СтрокаПодстановки, Позиция + 1, 1);
		ПодставляемыйПараметр = "";
		Если СимволПослеПроцента = "1" Тогда
			ПодставляемыйПараметр =  Параметр1;
		ИначеЕсли СимволПослеПроцента = "2" Тогда
			ПодставляемыйПараметр =  Параметр2;
		ИначеЕсли СимволПослеПроцента = "3" Тогда
			ПодставляемыйПараметр =  Параметр3;
		ИначеЕсли СимволПослеПроцента = "4" Тогда
			ПодставляемыйПараметр =  Параметр4;
		ИначеЕсли СимволПослеПроцента = "5" Тогда
			ПодставляемыйПараметр =  Параметр5;
		ИначеЕсли СимволПослеПроцента = "6" Тогда
			ПодставляемыйПараметр =  Параметр6;
		ИначеЕсли СимволПослеПроцента = "7" Тогда
			ПодставляемыйПараметр =  Параметр7
		ИначеЕсли СимволПослеПроцента = "8" Тогда
			ПодставляемыйПараметр =  Параметр8;
		ИначеЕсли СимволПослеПроцента = "9" Тогда
			ПодставляемыйПараметр =  Параметр9;
		КонецЕсли;
		Если ПодставляемыйПараметр = "" Тогда
			Результат = Результат + "%";
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 1);
		Иначе
			Результат = Результат + ПодставляемыйПараметр;
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 2);
		КонецЕсли;
		Позиция = Найти(СтрокаПодстановки, "%");
	КонецЦикла;
	Результат = Результат + СтрокаПодстановки;
	
	Возврат Результат;
КонецФункции
// Формирует сообщение при ошибках проведения документов.
//
// Параметры: 
//  ТекстСообщения - Исходный текст, выводимого сообщения,
//  Отказ          - Флаг отказа в проведении докумета,
//  Заголовок      - Заголовок начала серии сообщений об ошибках проведения (не обязательный)
//
Процедура ОшибкаПриПроведении(ТекстСообщения, Отказ, Заголовок="") Экспорт

	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок);

КонецПроцедуры // ОшибкаПриПроведении()

// Формирует строку представления документа для сообщений при проведении.
//
// Параметры
//  Документ - ссылка на проводимый документ.
//
// Возвращаемое значение
//  Строка с представлением документа.
//
Функция ПредставлениеДокументаПриПроведении(Документ) Экспорт

	МетаданныеДокумента = Документ.Метаданные();

	ВидОперацииСтр = "";
	Если ЕстьРеквизитДокумента("ВидОперации", МетаданныеДокумента) Тогда
		ВидОперацииСтр = " (" + Документ.ВидОперации + ")";
	КонецЕсли;

	Возврат "Проведение документа: " + СокрЛП(Документ) + ВидОперацииСтр;

КонецФункции // ПредставлениеДокументаПриПроведении()

// Проверяет принадлежность документа к видам учета
//
// Параметры: 
//  СтруктураШапкиДокумента - структура, содержащая реквизиты шапки документа
//  Отказ                   - флаг отказа в проведении.
//  Заголовок               - строка, заголовок сообщения об ошибке проведения.
//  МожетБытьТолькоНалоговый- строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь) Экспорт
	
	Перем Упр, Бух, Нал;
	
	ЕстьУпр = СтруктураШапкиДокумента.Свойство("ОтражатьВУправленческомУчете", Упр);
	ЕстьБух = СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете", Бух);
	ЕстьНал = СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете", Нал);
	
	Если ЕстьУпр ИЛИ ЕстьБух ИЛИ ЕстьНал Тогда
		Если НЕ МожетБытьТолькоНалоговый Тогда
			Если Упр <> Истина И Бух <> Истина  Тогда
				ОшибкаПриПроведении("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"" и (или)  ""Бухгалтерский"".", Отказ, Заголовок);
			ИначеЕсли Бух <> Истина И Нал = Истина Тогда
				ОшибкаПриПроведении("Документ не может проводиться  по налоговому учету, если он не проводится по бухгалтерскому учету." , Отказ, Заголовок);
			КонецЕсли;
		Иначе
			Если Упр <> Истина И Бух <> Истина И Нал <> Истина Тогда
				ОшибкаПриПроведении("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"", ""Бухгалтерский"", ""Налоговый"".", Отказ, Заголовок);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

// Проверяет правильность заполнения шапки документа.
// Если какой-то из реквизтов шапки, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
//
// Параметры: 
//  ДокументОбъект             - объект проводимого документа, 
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеШапкиДокумента(ДокументОбъект, СтруктураОбязательныхПолей, Отказ, Заголовок) Экспорт
	
	//ПроверитьПринадлежностьКВидамУчета();

	МетаданныеРеквизиты = ДокументОбъект.Метаданные().Реквизиты;
	
	Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

		Значение = ДокументОбъект[КлючЗначение.Ключ];
		Если ЗначениеНеЗаполнено(Значение) Тогда // надо ругаться

			Если ЗначениеНеЗаполнено(КлючЗначение.Значение) Тогда //стандартное ругательство
				ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
				СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";
			Иначе
				СтрокаСообщения = КлючЗначение.Значение;
			КонецЕсли;
			ОшибкаПриПроведении(СтрокаСообщения, Отказ, Заголовок);

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ПроверитьЗаполнениеШапкиДокумента()

// Проверяет правильность заполнения строк табличной части документа.
// Если какой-то из реквизтов, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
//
// Параметры:
//  ДокументОбъект             - объект проводимого документа, 
//  ИмяТабличнойЧасти          - табличная часть документа,
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, СтруктураОбязательныхПолей, 
                                                    Отказ, Заголовок) Экспорт

	ПредставлениеТабличнойЧасти = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Представление();
	ТабличнаяЧасть = ДокументОбъект[ИмяТабличнойЧасти];
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты;

	// Цмкл по строкам табличной части.
	Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл

		СтрокаНачалаСообщенияОбОшибке = "В строке номер """+ СокрЛП(СтрокаТаблицы.НомерСтроки) +
		                               """ табличной части """ + ПредставлениеТабличнойЧасти + """: ";

		// Цмкл по проверяемым полям
		Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

			Значение = СтрокаТаблицы[КлючЗначение.Ключ];
			Если ЗначениеНеЗаполнено(Значение) Тогда // надо ругаться

				Если ЗначениеНеЗаполнено(КлючЗначение.Значение) Тогда //стандартное ругательство
					ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
					СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";
				Иначе
					СтрокаСообщения = КлючЗначение.Значение;
				КонецЕсли;
				ОшибкаПриПроведении(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);

			КонецЕсли;

		КонецЦикла;

	КонецЦикла;

КонецПроцедуры // ПроверитьЗаполнениеТабличнойЧасти()

// Проверяет возможность проведения в БУ и НУ в зависимости от договора взаиморасчетов.
//
// Параметры:
//  ДоговорКонтрагента             - ссылка на справочник договора, определяет договор с контрагентом;
//  ВалютаДокумента                - ссылка на справочник валют, определяет валюту документа;
//  ОтражатьВБухгалтерскомУчете    - булево, признак отражения документа в бух. учете;
//  ОтражатьВНалоговомУчете        - булево, признак отражения документа в налоговом учете;
//  ВалютаРегламентированногоУчета - ссылка на справочник валют, определяет валюту ведения регл. учета;
//  ЭтоДокументОплаты              - булево, определяет является ли это документом оплаты,
//                                   необязательный параметр, по умолчанию - Ложь;
//  Отказ                          - булево, признак отказа в проведении документаРасчетыВУсловныхЕдиницах;
//  Заголовок                      - строка, заголовок сообщения в отказе проведения;
//  ДополнениеКСообщению           - строка, дополнение к сообщению в отказе проведении, 
//                                   необязательный, по умолчанию - пустая строка;
//  ВалютаВзаиморасчетов           - ссылка на справочник валют, определяет валюту взаиморасчетов по договору,
//                                   если не передан, берется из договора;
//  РасчетыВУсловныхЕдиницах - булево, признак ведения взаиморасчетов в условных единицах,
//                                   если не передан, берется из договора.
//
// Возвращаемое значение:
//  Истина, если документ можно проводить по бух. или (и) налоговому учету, инчае - Ложь.
//
Функция ПроверкаВозможностиПроведенияВ_БУ_НУ(ДоговорКонтрагента, ВалютаДокумента,ОтражатьВБухгалтерскомУчете,
                          ОтражатьВНалоговомУчете, ВалютаРегламентированногоУчета, ЭтоДокументОплаты = Ложь,
                          Отказ = Ложь, Заголовок,ДополнениеКСообщению = "",
                          ВалютаВзаиморасчетов = Неопределено, РасчетыВУсловныхЕдиницах = Неопределено) Экспорт

	Если ЗначениеНеЗаполнено(ДоговорКонтрагента) Тогда
		Возврат Истина;
	КонецЕсли;

	// ???? На всякий случай оставим следующие три проверки:
	Если ЗначениеНеЗаполнено(ВалютаРегламентированногоУчета) Тогда
		ВалютаРегламентированногоУчета = Константы.ВалютаРегламентированногоУчета.Получить();
	КонецЕсли;

	Если ВалютаВзаиморасчетов = Неопределено Тогда
		ВалютаВзаиморасчетов = ДоговорКонтрагента.ВалютаВзаиморасчетов;
	КонецЕсли;

	Если РасчетыВУсловныхЕдиницах = Неопределено Тогда
		РасчетыВУсловныхЕдиницах = ДоговорКонтрагента.РасчетыВУсловныхЕдиницах;
	КонецЕсли;

	Если ВалютаВзаиморасчетов <> ВалютаДокумента 
	   И ВалютаРегламентированногоУчета <> ВалютаДокумента Тогда

		// Документ выписан в валюте отличной от валюты регламентированного учета и валюты расчетов. 
		// Возможно только в документах оплаты.
		// Не отражается в б.у.
		Если ОтражатьВБухгалтерскомУчете 
		 Или ОтражатьВНалоговомУчете Тогда
			СообщитьОбОшибке(ДополнениеКСообщению + " Валюта документа ("+СокрЛП(ВалютаДокумента)
			                 + ") отличается от валюты регламентированного учета (" + СокрЛП(ВалютаРегламентированногоУчета)
			                 + ") и валюты расчетов по договору """ + СокрЛП(ДоговорКонтрагента) 
			                 + """ (" + СокрЛП(ВалютаВзаиморасчетов) + ").
			|Документ не может быть проведен по бухгалтерскому или налоговому учету.",Отказ,Заголовок);
			Возврат Ложь;
		КонецЕсли;

	ИначеЕсли ВалютаДокумента = ВалютаРегламентированногоУчета Тогда

		Если (Не ВалютаВзаиморасчетов = ВалютаРегламентированногоУчета) 
		   И Не(РасчетыВУсловныхЕдиницах) Тогда

			// Документ выписан в валюте регламентированного учета. 
			// Валюта расчетов иная. Договор не в у.е. 
			// Не отражается в б.у.
			Если ОтражатьВБухгалтерскомУчете 
			 Или ОтражатьВНалоговомУчете Тогда 
				СообщитьОбОшибке(ДополнениеКСообщению + " Валюта расчетов по договору """ + СокрЛП(ДоговорКонтрагента) 
				                 + """ (" + СокрЛП(ВалютаВзаиморасчетов) + ") отличается от валюты регламентированного учета ("
				                 + СокрЛП(ВалютаРегламентированногоУчета) + ").
				|В этом случае документы могут быть выписаны в валюте регламентированного учета только при расчетах в условных единицах.
				|Документ не может быть проведен по бухгалтерскому или налоговому учету.",Отказ,Заголовок);
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;

	Иначе

		// Валюта документа равна валюте взаиморасчетов (отличной от валюты  рег. учета).
		Если РасчетыВУсловныхЕдиницах
		   И ЭтоДокументОплаты Тогда 

			// При расчетах в у.е. документы оплаты могут выписываться только в валюте рег.учета.
			// Не отражается в б.у.
			Если ОтражатьВБухгалтерскомУчете 
			 Или ОтражатьВНалоговомУчете Тогда
				СообщитьОбОшибке(ДополнениеКСообщению + " Документ оплаты при расчете по договору (" + СокрЛП(ДоговорКонтрагента) 
				                 + ")в условных единицах может быть выписан только в валюте регламентированного учета ("
				                 + СокрЛП(ВалютаРегламентированногоУчета) + ").
				|Документ не может быть проведен по бухгалтерскому или налоговому учету.",Отказ,Заголовок);
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Возврат Истина;

КонецФункции // ПроверкаВозможностиПроведенияВ_БУ_НУ()

// Процедура вызывается для вывода сообщений пользователю
//
// Параметры:
//  СсылкаСправочника - ссылка на справочник, объект которого проверяется;
//  ИмяРеквизита - строка, имя реквизита, который не заполнен.
//
Процедура СообщитьПользователюНезаполненРеквизит(СсылкаСправочника, ИмяРеквизита) Экспорт

	ТекстСообщения = "Перед записью в элементе справочника """ + СсылкаСправочника.Метаданные().Синоним + """ необходимо заполнить """ + ИмяРеквизита + """!";
	
	#Если ВнешнееСоединение Тогда			
	#Иначе
		Сообщить(ТекстСообщения, СтатусСообщения.Важное);
	#КонецЕсли

КонецПроцедуры // СообщитьПользователюНезаполненРеквизит()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ

// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт

	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;

КонецФункции // ПолучитьСписокЭлементовПеречисления()

Функция ПолучитьСписокПрочихСостоянийРаботника() Экспорт

	СписокСпособов = Новый СписокЗначений;
	
	СписокСпособов.Добавить(Перечисления.СостоянияРаботникаОрганизации.Заболевание);
	СписокСпособов.Добавить(Перечисления.СостоянияРаботникаОрганизации.ОтсутствуетПоНевыясненнойПричине);
	СписокСпособов.Добавить(Перечисления.СостоянияРаботникаОрганизации.Работает);
	
	Возврат СписокСпособов
	
КонецФункции // ПолучитьСписокЭлементовПеречисления()

// Предназначена для получения имени элемента перечисления по значению.
//
// Параметры:
//	Элемент перечисления.
//
// Возвращаемое значение:
//	Строка - имя элемента перечисления в метаданных.
//
Функция ПолучитьИмяЭлементаПеречисленияПоЗначению(ЗначениеПеречисления) Экспорт
	
	ИмяЭлемента = Строка(ЗначениеПеречисления);
	Для каждого ЭлементПеречисления Из Метаданные.Перечисления[ЗначениеПеречисления.Метаданные().Имя].ЗначенияПеречисления Цикл
		Если ЭлементПеречисления.Синоним = Строка(ЗначениеПеречисления) Тогда
			ИмяЭлемента = ЭлементПеречисления.Имя;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат ИмяЭлемента;
	
КонецФункции // ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ

// Функция возвращает имя табличной части, к которой принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Строка - имя табличной части, как оно задано в конфигураторе
//
Функция ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	ИмяТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;
	Возврат ИмяТабличнойЧасти;

КонецФункции // ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()

// Функция возвращает метаданные документа, которому принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Метаданные - метаданные документа, как оно задано в конфигураторе
//
Функция ПолучитьМетаданныеДокументаПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Родитель();
	Возврат МетаданныеДокумента;

КонецФункции // ПолучитьМетаданныеДокументаПоСсылкеНаСтроку()

////////////////////////////////////////////////////////////////////////////////
// ОБЩИЕ ПРОЦЕДУРЫ ЗАПОЛНЕНИЯ ДОКУМЕНТОВ

// Процедура предназначена для заполнения общих реквизитов документов по документу основанию,
//	вызывается в обработчиках событий "ОбработкаЗаполнения" в модулях документов.
//
// Параметры:
//  ДокументОбъект  - объект редактируемого документа,
//  ДокументОснование - объект документа основания
//
Процедура ЗаполнитьШапкуДокументаПоОснованию(ДокументОбъект, ДокументОснование) Экспорт

	МетаданныеДокумента          = ДокументОбъект.Метаданные();
	МетаданныеДокументаОснования = ДокументОснование.Метаданные();

	// Организация.
	Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("Организация", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Организация = ДокументОснование.Организация;
	КонецЕсли;

	// Организация для печати
	Если ЕстьРеквизитДокумента("ОрганизацияДляПечати", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ОрганизацияДляПечати", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.ОрганизацияДляПечати = ДокументОснование.ОрганизацияДляПечати;
	КонецЕсли;
	
	// Подразделение.
	Если ЕстьРеквизитДокумента("Подразделение", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("Подразделение", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Подразделение = ДокументОснование.Подразделение;
	КонецЕсли;

	// Склад.
	Если ЕстьРеквизитДокумента("Склад", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("Склад", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Склад = ДокументОснование.Склад;
	КонецЕсли;

	// Контрагент.
	Если ЕстьРеквизитДокумента("Контрагент", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("Контрагент", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.Контрагент = ДокументОснование.Контрагент;
	КонецЕсли;

	// ДоговорКонтрагента.
	Если ЕстьРеквизитДокумента("ДоговорКонтрагента", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ДоговорКонтрагента", МетаданныеДокументаОснования) 
	   И (НЕ ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) 
	      ИЛИ ДокументОбъект.Организация = ДокументОснование.ДоговорКонтрагента.Организация) Тогда

		ДокументОбъект.ДоговорКонтрагента = ДокументОснование.ДоговорКонтрагента;

		// КурсВзаиморасчетов.
		Если ЕстьРеквизитДокумента("КурсВзаиморасчетов", МетаданныеДокумента) Тогда
			СтруктураКурсаВзаиморасчетов = ПолучитьКурсВалюты(ДокументОбъект.ДоговорКонтрагента.ВалютаВзаиморасчетов, ТекущаяДата());
			ДокументОбъект.КурсВзаиморасчетов = СтруктураКурсаВзаиморасчетов.Курс;

			// КратностьВзаиморасчетов.
			Если ЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента) Тогда
				ДокументОбъект.КратностьВзаиморасчетов = СтруктураКурсаВзаиморасчетов.Кратность;
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;

	// Касса
	Если ЕстьРеквизитДокумента("Касса", МетаданныеДокумента) Тогда

		// Если в документе-основании есть структурная единица(или касса), то берем ее оттуда
		Если ЕстьРеквизитДокумента("СтруктурнаяЕдиница", МетаданныеДокументаОснования) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОснование.СтруктурнаяЕдиница) 
			   И ТипЗнч(ДокументОснование.СтруктурнаяЕдиница) = Тип("СправочникСсылка.Кассы") Тогда
				ДокументОбъект.Касса = ДокументОснование.СтруктурнаяЕдиница;
			КонецЕсли;
		ИначеЕсли ЕстьРеквизитДокумента("Касса", МетаданныеДокументаОснования) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОснование.Касса) Тогда
				ДокументОбъект.Касса = ДокументОснование.Касса;
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;

	// Банковский счет 
	Если ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента) Тогда

		// Если в документе-основании есть структурная единица(или касса), то берем ее оттуда
		Если ЕстьРеквизитДокумента("СтруктурнаяЕдиница", МетаданныеДокументаОснования) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОснование.СтруктурнаяЕдиница) 
			   И ТипЗнч(ДокументОснование.СтруктурнаяЕдиница) = Тип("СправочникСсылка.БанковскиеСчета") Тогда
				ДокументОбъект.БанковскийСчет = ДокументОснование.СтруктурнаяЕдиница;
			КонецЕсли;
		ИначеЕсли ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокументаОснования) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОснование.БанковскийСчет) Тогда
				ДокументОбъект.БанковскийСчет = ДокументОснование.БанковскийСчет;
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	// Банковский счет организации
	Если ЕстьРеквизитДокумента("БанковскийСчетОрганизации", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокументаОснования) Тогда

		Если ЗначениеНеЗаполнено(ДокументОбъект.БанковскийСчетОрганизации)
		  И НЕ ЗначениеНеЗаполнено(ДокументОбъект.БанковскийСчет)Тогда
			ДокументОбъект.БанковскийСчетОрганизации = ДокументОснование.БанковскийСчет;
		КонецЕсли;
	КонецЕсли;

	// ВалютаДокумента.
	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокументаОснования) Тогда

		// Если есть касса или банковский счет, то валюта должна браться только оттуда
		Если ЕстьРеквизитДокумента("Касса", МетаданныеДокумента) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОбъект.Касса) Тогда
				ДокументОбъект.ВалютаДокумента = ДокументОбъект.Касса.ВалютаДенежныхСредств;
			КонецЕсли;
		ИначеЕсли ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента) Тогда
			Если Не ЗначениеНеЗаполнено(ДокументОбъект.БанковскийСчет) Тогда
				ДокументОбъект.ВалютаДокумента = ДокументОбъект.БанковскийСчет.ВалютаДенежныхСредств;
		    КонецЕсли;
		Иначе
			ДокументОбъект.ВалютаДокумента = ДокументОснование.ВалютаДокумента;
		КонецЕсли;

		// КурсДокумента.
		Если ЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента) Тогда
			СтруктураКурсаДокумента = ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента, ТекущаяДата());
			ДокументОбъект.КурсДокумента = СтруктураКурсаДокумента.Курс;

			// КратностьДокумента.
			Если ЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
				ДокументОбъект.КратностьДокумента = СтруктураКурсаДокумента.Кратность;
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;

	// ТипЦен.
	Если ЕстьРеквизитДокумента("ТипЦен", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ТипЦен", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.ТипЦен = ДокументОснование.ТипЦен;
	КонецЕсли;

	// Тип скидки.
	Если ЕстьРеквизитДокумента("ТипСкидкиНаценки", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ТипСкидкиНаценки", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.ТипСкидкиНаценки = ДокументОснование.ТипСкидкиНаценки;
	КонецЕсли;
	// Тип скидки.
	Если ЕстьРеквизитДокумента("ДисконтнаяКарта", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("ДисконтнаяКарта", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.ДисконтнаяКарта = ДокументОснование.ДисконтнаяКарта;
	КонецЕсли;

	// УчитыватьНДС.
	Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.УчитыватьНДС = ДокументОснование.УчитыватьНДС;
	КонецЕсли;

	// СуммаВключаетНДС.
	Если ЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокумента)
	   И ЕстьРеквизитДокумента("СуммаВключаетНДС", МетаданныеДокументаОснования) Тогда
		ДокументОбъект.СуммаВключаетНДС = ДокументОснование.СуммаВключаетНДС;
	КонецЕсли;

	// ОтражатьВУправленческомУчете.
	// Если есть в основании, копируем из основания, иначе - Истина.
	Если ЕстьРеквизитДокумента("ОтражатьВУправленческомУчете", МетаданныеДокумента) Тогда
		Если ЕстьРеквизитДокумента("ОтражатьВУправленческомУчете", МетаданныеДокументаОснования) Тогда
			
			Если ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "НеОтражатьДокументыВУправленческомУчете") Тогда
				
				ДокументОбъект.ОтражатьВУправленческомУчете = Ложь;
				
			Иначе
				
				ДокументОбъект.ОтражатьВУправленческомУчете = ДокументОснование.ОтражатьВУправленческомУчете;	
				
			КонецЕсли; 
			
		Иначе
			
			Если ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "НеОтражатьДокументыВУправленческомУчете") Тогда
				
				ДокументОбъект.ОтражатьВУправленческомУчете = Ложь;
				
			Иначе
				
				ДокументОбъект.ОтражатьВУправленческомУчете = Истина;
				
			КонецЕсли; 
			
			
		КонецЕсли;
	КонецЕсли;
	
	Если ЕстьРеквизитДокумента("ОтражатьВБухгалтерскомУчете", МетаданныеДокумента) Тогда
		
		Если ЕстьРеквизитДокумента("ОтражатьВБухгалтерскомУчете", МетаданныеДокументаОснования) Тогда
			
			Если НЕ ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "НеОтражатьДокументыВУправленческомУчете")
				И НЕ ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "НеОтражатьДокументыВБухгалтерскомУчете") Тогда
				
				ДокументОбъект.ОтражатьВБухгалтерскомУчете = ДокументОснование.ОтражатьВБухгалтерскомУчете;
				
			Иначе
				
				ДокументОбъект.ОтражатьВБухгалтерскомУчете = Ложь;
				
			КонецЕсли;
			
		Иначе
			
			Если НЕ ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "НеОтражатьДокументыВУправленческомУчете")
				И НЕ ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "НеОтражатьДокументыВБухгалтерскомУчете") Тогда
				//ДокументОбъект.ОтражатьВБухгалтерскомУчете = ДокументОснование.ОтражатьВБухгалтерскомУчете;
				
				ДокументОбъект.ОтражатьВБухгалтерскомУчете = Истина;
				
			Иначе
				
				ДокументОбъект.ОтражатьВБухгалтерскомУчете = Ложь;
				
			КонецЕсли;
			
			
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЕстьРеквизитДокумента("ОтражатьВНалоговомУчете", МетаданныеДокумента) Тогда
		Если ЕстьРеквизитДокумента("ОтражатьВНалоговомУчете", МетаданныеДокументаОснования) Тогда
			
			Если НЕ ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "НеОтражатьДокументыВУправленческомУчете")
				И НЕ ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "НеОтражатьДокументыВБухгалтерскомУчете")
				И НЕ ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "НеОтражатьДокументыВНалоговомУчете") Тогда
				
				ДокументОбъект.ОтражатьВНалоговомУчете = ДокументОснование.ОтражатьВНалоговомУчете;
				
			Иначе
				
				ДокументОбъект.ОтражатьВНалоговомУчете = Ложь;
				
			КонецЕсли;
			
			
		Иначе
			Если НЕ ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "НеОтражатьДокументыВУправленческомУчете")
				И НЕ ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "НеОтражатьДокументыВБухгалтерскомУчете")
				И НЕ ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "НеОтражатьДокументыВНалоговомУчете") Тогда
				
				ДокументОбъект.ОтражатьВНалоговомУчете = Истина;
				
			Иначе
				
				ДокументОбъект.ОтражатьВНалоговомУчете = Ложь;
				
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если ЕстьРеквизитДокумента("ИспользоватьПлановуюСебестоимость", МетаданныеДокумента) Тогда
		Если ЕстьРеквизитДокумента("ИспользоватьПлановуюСебестоимость", МетаданныеДокументаОснования) Тогда
			ДокументОбъект.ИспользоватьПлановуюСебестоимость = ДокументОснование.ИспользоватьПлановуюСебестоимость;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры // ЗаполнитьШапкуДокументаПоОснованию()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Процедура заполняет кассу по сделке или значением по умолчанию
//
// Параметры:
//	ДокументОбъект - объект редактируемого документа
//	ТекПользователь - ссылка на справочник, определяет текущего пользователя  
//
Процедура ЗаполнитьКассу(ДокументОбъект, ТекПользователь) Экспорт
	
	// Если кассу уже заполнена ранее, то здесь ничего делать не надо
	Если Не ЗначениеНеЗаполнено(ДокументОбъект.Касса) Тогда
		Возврат;
	КонецЕсли;
	
	Если ЕстьРеквизитДокумента("Сделка", ДокументОбъект.Метаданные()) Тогда
		
		МетаданныеДокументаСделка = ДокументОбъект.Сделка.Метаданные();
		
		Если Не ЗначениеНеЗаполнено(ДокументОбъект.Сделка) Тогда
			Если ЕстьРеквизитДокумента("СтруктурнаяЕдиница", МетаданныеДокументаСделка) Тогда
				ДокументОбъект.Касса = ДокументОбъект.Сделка.СтруктурнаяЕдиница;
			ИначеЕсли ЕстьРеквизитДокумента("Касса", МетаданныеДокументаСделка) Тогда
				ДокументОбъект.Касса = ДокументОбъект.Сделка.Касса;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;

	Если ЗначениеНеЗаполнено(ДокументОбъект.Касса) Тогда
		ДокументОбъект.Касса = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнаяКасса");
	КонецЕсли;

	ДокументОбъект.ВалютаДокумента    = ДокументОбъект.Касса.ВалютаДенежныхСредств;
	СтруктураКурсаДокумента           = ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента, ДокументОбъект.Дата);
	ДокументОбъект.КурсДокумента      = СтруктураКурсаДокумента.Курс;
	ДокументОбъект.КратностьДокумента = СтруктураКурсаДокумента.Кратность;
	
КонецПроцедуры // ЗаполнитьКассу()

// Процедура предназначена для заполнения общих реквизитов документов,
// вызывается в обработчиках событий "ПриОткрытии" в модулех форм всех документов.
//
// Параметры:
//  ДокументОбъект                 - объект редактируемого документа,
//  ТекПользователь                - ссылка на справочник, определяет текущего пользователя  
//  ВалютаРегламентированногоУчета - валюта регламентированного учета
//  ТипОперации                    - необязаетельный, строка вида операции ("Покупка" или "Продажа"),
//                                   если не передан, то реквизиты, зависящие от вида операции, не заполняются
//
Процедура ЗаполнитьШапкуДокумента(ДокументОбъект, ТекПользователь, ВалютаРегламентированногоУчета = Неопределено, ТипОперации = "") Экспорт

	Перем ТипЦен;

	МетаданныеДокумента = ДокументОбъект.Метаданные();

	// Заполним флаги принадлежности к учету исходя из значений по умолчанию.
	Если ЕстьРеквизитДокумента("ОтражатьВУправленческомУчете", МетаданныеДокумента) Тогда

		ДокументОбъект.ОтражатьВУправленческомУчете = НЕ ПолучитьЗначениеПоУмолчанию(ТекПользователь, "НеОтражатьДокументыВУправленческомУчете");

	КонецЕсли;

	//Флаги БУ и НУ взаимосвязаны, не возможна ситуация, когда флаг НУ "истина". а флаг БУ "ложь".
	Если ЕстьРеквизитДокумента("ОтражатьВБухгалтерскомУчете", МетаданныеДокумента) Тогда

		ФлагОтражатьВБухгалтерскомУчете = НЕ ПолучитьЗначениеПоУмолчанию(ТекПользователь, "НеОтражатьДокументыВБухгалтерскомУчете");

		ДокументОбъект.ОтражатьВБухгалтерскомУчете  = ФлагОтражатьВБухгалтерскомУчете;

		Если ЕстьРеквизитДокумента("ОтражатьВНалоговомУчете", МетаданныеДокумента) Тогда

			Если ФлагОтражатьВБухгалтерскомУчете Тогда
				ДокументОбъект.ОтражатьВНалоговомУчете = НЕ ПолучитьЗначениеПоУмолчанию(ТекПользователь, "НеОтражатьДокументыВНалоговомУчете");
			Иначе
				ДокументОбъект.ОтражатьВНалоговомУчете = ФлагОтражатьВБухгалтерскомУчете;
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;

	Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) 
	  И (ЗначениеНеЗаполнено(ДокументОбъект.Организация)) Тогда
		ДокументОбъект.Организация = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнаяОрганизация");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("СтруктурнаяЕдиница", МетаданныеДокумента)
	   И ЗначениеНеЗаполнено(ДокументОбъект.СтруктурнаяЕдиница) 
	   И ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда
		ДокументОбъект.СтруктурнаяЕдиница = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("Подразделение", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.Подразделение)) Тогда
		ДокументОбъект.Подразделение = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновноеПодразделение");
	КонецЕсли;
	
	Если ЕстьРеквизитДокумента("Ответственный", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.Ответственный)) Тогда
		ДокументОбъект.Ответственный = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойОтветственный");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ВидОперации", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ВидОперации)) Тогда
		ДокументОбъект.ВидОперации = Перечисления[ДокументОбъект.ВидОперации.Метаданные().Имя][0];
	КонецЕсли;

	Если ЕстьРеквизитДокумента("Склад", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.Склад)) Тогда
		ДокументОбъект.Склад = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойСклад");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("СкладОрдер", МетаданныеДокумента) И ЕстьРеквизитДокумента("ВидПоступления", МетаданныеДокумента)
	   И ЗначениеНеЗаполнено(ДокументОбъект.СкладОрдер) И ЗначениеНеЗаполнено(ДокументОбъект.ВидПоступления) Тогда
		ДокументОбъект.СкладОрдер = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойСклад");
		ДокументОбъект.ВидПоступления = Перечисления.ВидыПоступленияТоваров.НаСклад;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("Касса", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.Касса)) Тогда
		ДокументОбъект.Касса = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнаяКасса");
		Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда
			ДокументОбъект.ВалютаДокумента = ДокументОбъект.Касса.ВалютаДенежныхСредств;
		КонецЕсли;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("КассаККМ", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.КассаККМ)) Тогда
		ДокументОбъект.КассаККМ = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнаяКассаККМ");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("СтавкаНДС", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.СтавкаНДС)) Тогда
		ДокументОбъект.СтавкаНДС = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнаяСтавкаНДС");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("БанковскийСчет", МетаданныеДокумента)
	   И ЗначениеНеЗаполнено(ДокументОбъект.БанковскийСчет)
	   И (Не ЗначениеНеЗаполнено(ДокументОбъект.Организация.ЮрФизЛицо)) Тогда
		ДокументОбъект.БанковскийСчет = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
		Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда
			ДокументОбъект.ВалютаДокумента = ДокументОбъект.Организация.ОсновнойБанковскийСчет.ВалютаДенежныхСредств;
		КонецЕсли;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("СчетОрганизации", МетаданныеДокумента)
	   И ЗначениеНеЗаполнено(ДокументОбъект.СчетОрганизации)
	   И (Не ЗначениеНеЗаполнено(ДокументОбъект.Организация.ЮрФизЛицо)) Тогда
		ДокументОбъект.СчетОрганизации = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
		Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента) Тогда
			ДокументОбъект.ВалютаДокумента = ДокументОбъект.Организация.ОсновнойБанковскийСчет.ВалютаДенежныхСредств;
		КонецЕсли;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ИспользоватьПлановуюСебестоимость", МетаданныеДокумента) 
		И НЕ ДокументОбъект.ИспользоватьПлановуюСебестоимость Тогда
		ДокументОбъект.ИспользоватьПлановуюСебестоимость = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ИспользоватьПлановуюСебестоимость");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("АвтоРезервирование", МетаданныеДокумента) Тогда
		ДокументОбъект.АвтоРезервирование = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "АвтоРезервирование");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("АвтоРазмещение", МетаданныеДокумента) Тогда
		ДокументОбъект.АвтоРазмещение = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "АвтоРазмещение");
	КонецЕсли;

	Если ЕстьРеквизитДокумента("Контрагент", МетаданныеДокумента) Тогда

		Если ЗначениеНеЗаполнено(ДокументОбъект.Контрагент) Тогда
			Если ТипОперации = "Покупка" Тогда
				ДокументОбъект.Контрагент = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойПоставщик");
			ИначеЕсли ТипОперации = "Продажа" Тогда
				ДокументОбъект.Контрагент = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойПокупатель");
			КонецЕсли;
		КонецЕсли;

		Если ЕстьРеквизитДокумента("КонтактноеЛицо", МетаданныеДокумента) Тогда
			Если (ЗначениеНеЗаполнено(ДокументОбъект.КонтактноеЛицо))
			   И ТипЗнч(ДокументОбъект.Контрагент) = Тип("СправочникСсылка.Контрагенты")
			   И НЕ ЗначениеНеЗаполнено(ДокументОбъект.Контрагент) Тогда
				ДокументОбъект.КонтактноеЛицо = ДокументОбъект.Контрагент.ОсновноеКонтактноеЛицо;
			Иначе
				ДокументОбъект.КонтактноеЛицо = Справочники.КонтактныеЛица.ПустаяСсылка();
			КонецЕсли;
		КонецЕсли;

		Если ЕстьРеквизитДокумента("ДоговорКонтрагента", МетаданныеДокумента) Тогда

			Если ЗначениеНеЗаполнено(ДокументОбъект.ДоговорКонтрагента) И ТипЗнч(ДокументОбъект.Контрагент) = Тип("СправочникСсылка.Контрагенты") Тогда
				Если НЕ ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
				 ИЛИ ДокументОбъект.Контрагент.ОсновнойДоговорКонтрагента.Организация = ДокументОбъект.Организация
				 ИЛИ ЗначениеНеЗаполнено(ДокументОбъект.Организация) Тогда

					// Может, надо проверить еще вид договора
					Если ТипОперации = "Продажа" Тогда 
						ВидДоговора = ДокументОбъект.Контрагент.ОсновнойДоговорКонтрагента.ВидДоговора;
						Если ВидДоговора = Перечисления.ВидыДоговоровКонтрагентов.СПокупателем
						 Или ВидДоговора = Перечисления.ВидыДоговоровКонтрагентов.СКомиссионером Тогда
							ДокументОбъект.ДоговорКонтрагента = ДокументОбъект.Контрагент.ОсновнойДоговорКонтрагента;
						КонецЕсли;
					ИначеЕсли ТипОперации = "Покупка" Тогда 
						ВидДоговора = ДокументОбъект.Контрагент.ОсновнойДоговорКонтрагента.ВидДоговора;
						Если ВидДоговора = Перечисления.ВидыДоговоровКонтрагентов.СПоставщиком
						 Или ВидДоговора = Перечисления.ВидыДоговоровКонтрагентов.СКомитентом Тогда
							ДокументОбъект.ДоговорКонтрагента = ДокументОбъект.Контрагент.ОсновнойДоговорКонтрагента;
						КонецЕсли;
					Иначе
						ДокументОбъект.ДоговорКонтрагента = ДокументОбъект.Контрагент.ОсновнойДоговорКонтрагента;
					КонецЕсли;

				КонецЕсли;
			КонецЕсли;

			Если Не ЗначениеНеЗаполнено(ДокументОбъект.ДоговорКонтрагента) Тогда
				ЕстьРеквизитКурсВзаиморасчетов      = ЕстьРеквизитДокумента("КурсВзаиморасчетов", МетаданныеДокумента);
				ЕстьРеквизитКратностьВзаиморасчетов = ЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента);

				Если ЕстьРеквизитКурсВзаиморасчетов ИЛИ ЕстьРеквизитКратностьВзаиморасчетов Тогда
					СтруктураКурсаВзаиморасчетов = ПолучитьКурсВалюты(ДокументОбъект.ДоговорКонтрагента.ВалютаВзаиморасчетов, ТекущаяДата());
				КонецЕсли;

				Если ЕстьРеквизитКурсВзаиморасчетов Тогда
					ДокументОбъект.КурсВзаиморасчетов = СтруктураКурсаВзаиморасчетов.Курс;
				КонецЕсли;

				Если ЕстьРеквизитКурсВзаиморасчетов Тогда
					ДокументОбъект.КратностьВзаиморасчетов = СтруктураКурсаВзаиморасчетов.Кратность;
				КонецЕсли;

				Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента)
				   И (ЗначениеНеЗаполнено(ДокументОбъект.ВалютаДокумента)) Тогда
					ДокументОбъект.ВалютаДокумента = ДокументОбъект.ДоговорКонтрагента.ВалютаВзаиморасчетов;
				КонецЕсли;

				Если ЕстьРеквизитДокумента("ТипЦен", МетаданныеДокумента)
				   И (ЗначениеНеЗаполнено(ДокументОбъект.ТипЦен)) Тогда
					ДокументОбъект.ТипЦен = ДокументОбъект.ДоговорКонтрагента.ТипЦен;
				КонецЕсли;

			КонецЕсли;

		КонецЕсли; // есть реквизит договор

	КонецЕсли;// есть реквизит контрагент

	Если ЕстьРеквизитДокумента("ВалютаДокумента", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ВалютаДокумента)) Тогда
		ДокументОбъект.ВалютаДокумента = ВалютаРегламентированногоУчета;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("КурсДокумента", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.КурсДокумента)) Тогда
	    СтруктураКурсаДокумента      = ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента, ДокументОбъект.Дата);
		ДокументОбъект.КурсДокумента = СтруктураКурсаДокумента.Курс;

		Если ЕстьРеквизитДокумента("КратностьДокумента", МетаданныеДокумента) Тогда
			ДокументОбъект.КратностьДокумента = СтруктураКурсаДокумента.Кратность;
		КонецЕсли;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("КурсВзаиморасчетов", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.КурсВзаиморасчетов)) Тогда
	    СтруктураКурсаДокумента           = ПолучитьКурсВалюты(ВалютаРегламентированногоУчета, ДокументОбъект.Дата);
		ДокументОбъект.КурсВзаиморасчетов = СтруктураКурсаДокумента.Курс;

		Если ЕстьРеквизитДокумента("КратностьВзаиморасчетов", МетаданныеДокумента) Тогда
			ДокументОбъект.КратностьВзаиморасчетов = СтруктураКурсаДокумента.Кратность;
		КонецЕсли;
	КонецЕсли;

	// Если тип цен оказался не заполненным, то берем его из установок пользователя
	Если ЕстьРеквизитДокумента("ТипЦен", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ТипЦен)) Тогда
		Если ТипОперации = "Продажа" Тогда
			ДокументОбъект.ТипЦен = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновнойТипЦенПродажи");
		КонецЕсли;
	КонецЕсли;

	Если (ЕстьРеквизитДокумента("ТипЦен", МетаданныеДокумента))
	   И (Не ЗначениеНеЗаполнено(ДокументОбъект.ТипЦен)) Тогда

		// Если ТипЦен - элемент справочника ТипыЦенНоменклатуры и цены выбранного типа расчетные, 
		// то флаги включения налогов надо брать из базовой цены
		Если ДокументОбъект.ТипЦен.Метаданные().Имя = "ТипыЦенНоменклатуры" Тогда
			ТипЦен = ?(ДокументОбъект.ТипЦен.Рассчитывается, ДокументОбъект.ТипЦен.БазовыйТипЦен, ДокументОбъект.ТипЦен);
		Иначе
			ТипЦен = ДокументОбъект.ТипЦен;
		КонецЕсли;

		// Флаги учета налогов заполняем, только если флаг УчитыватьНДС не заполнен.
		Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента) 
		   И (Не ДокументОбъект.УчитыватьНДС) Тогда

			ДокументОбъект.УчитыватьНДС     = Истина;
			ДокументОбъект.СуммаВключаетНДС = ТипЦен.ЦенаВключаетНДС;

		КонецЕсли;
		
	Иначе

		// Заполним значениями по умолчанию (нет, либо не заполнен ТипЦен).
		// Флаги учета налогов заполняем, только если флаг УчитыватьНДС не заполнен.
		Если ЕстьРеквизитДокумента("УчитыватьНДС", МетаданныеДокумента) 
		   И (Не ДокументОбъект.УчитыватьНДС) Тогда

			ДокументОбъект.УчитыватьНДС     = Истина;
			ДокументОбъект.СуммаВключаетНДС = Истина;
		КонецЕсли;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ЗанимаемыхСтавок", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ЗанимаемыхСтавок)) Тогда
		ДокументОбъект.ЗанимаемыхСтавок = 1;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ДатаС", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ДатаС)) Тогда
		ДокументОбъект.ДатаС = ДокументОбъект.Дата;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ПериодРегистрации", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ПериодРегистрации)) Тогда
		ДокументОбъект.ПериодРегистрации = НачалоМесяца(ТекущаяДата());
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ВидПоступления", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ВидПоступления)) Тогда
		ДокументОбъект.ВидПоступления = Перечисления.ВидыПоступленияТоваров.НаСклад;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ВидПередачи", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ВидПередачи)) Тогда
		ДокументОбъект.ВидПередачи = Перечисления.ВидыПередачиТоваров.СоСклада;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("ПодразделениеОрганизации", МетаданныеДокумента)
	   И (ЗначениеНеЗаполнено(ДокументОбъект.ПодразделениеОрганизации)) Тогда
		ДокументОбъект.ПодразделениеОрганизации = ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОсновноеПодразделениеОрганизации");;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("БанковскийСчетОрганизации", МетаданныеДокумента)
	   И НЕ ЗначениеНеЗаполнено(ДокументОбъект.Организация)
	   И ЗначениеНеЗаполнено(ДокументОбъект.БанковскийСчетОрганизации) Тогда
		ДокументОбъект.БанковскийСчетОрганизации = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
	КонецЕсли;

	Если ЕстьРеквизитДокумента("БанковскийСчетКонтрагента", МетаданныеДокумента) 
	   И НЕ ЗначениеНеЗаполнено(ДокументОбъект.Контрагент)
	   И ЗначениеНеЗаполнено(ДокументОбъект.БанковскийСчетКонтрагента) Тогда
		ДокументОбъект.БанковскийСчетКонтрагента = ДокументОбъект.Контрагент.ОсновнойБанковскийСчет;
	КонецЕсли;

КонецПроцедуры // ЗаполнитьШапкуДокумента()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Удаляет движения документа по указанному регистру либо по всем регистрам. 
//
// Параметры:
//  Движения	- коллекция движений документа.
//  ИмяРегистра - имя регистра, движения по которому будут удалены;
//				необязательный, если не указан - удаляются все движения.
//
Процедура УдалитьДвиженияДокумента(Движения,ИмяРегистра = "") Экспорт
	
	Если ИмяРегистра = "" Тогда
		Для Каждого ДвиженияРегистра Из Движения Цикл
			ДвиженияРегистра.Очистить();
		КонецЦикла;
	Иначе
		Движения[ИмяРегистра].Очистить();
	КонецЕсли;
	
КонецПроцедуры // УдалитьДвиженияДокумента()

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт

	//Сформируем массив совпадающих колонок.
	МассивСовпадающихКолонок = Новый Массив();
	Для каждого Колонка Из ТаблицаПриемник.Колонки Цикл

		Если ТаблицаИсточник.Колонки.Найти(Колонка.Имя) <> Неопределено Тогда

			МассивСовпадающихКолонок.Добавить(Колонка.Имя);

		КонецЕсли;

	КонецЦикла;

	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл

		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();

		// Заполним значения в совпадающих колонках.
		Для каждого ЭлементМассива Из МассивСовпадающихКолонок Цикл

			СтрокаТаблицыПриемника[ЭлементМассива] = СтрокаТаблицыИсточника[ЭлементМассива];

		КонецЦикла;

	КонецЦикла;

КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

// Проверяет наличие требуемых данных в источнике и Формирует таблицу значений
//
// Параметры
//  Источник  – ТаблицаЗначений или ТабличнаяЧасть или КоллекцияСтрокДереваЗначений с исходными данными
//
//  Реквизиты – структура – Структура реквизитов. 
//							Ключ 		- Наименование колонки в источнике
//							Значение    - Наименование колонки в получаемой ТЗ
//							Если значение опущено - приравнивается ключу.
//	ПолучитьНомерСтрокиДокумента - булево
//	                        Используется только при выгрузке из табличной части документа.
//							В формируемой таблице создает новую колонку "НомерСтрокиДокумента"
//								и заполняет её реальными номерами строк
//
//  КоллекцияКолонокДереваЗначений - только для коллекции строк дерева значений.
// Возвращаемое значение:
//  Таблица значений или Неопределено (если не хватает реквизитов)
//
Функция СформироватьТаблицуЗначений(Источник,Реквизиты=Неопределено,ПолучитьНомерСтрокиДокумента = ложь,ФормироватьОтстутствующиеКолонки=Ложь,КоллекцияКолонокДереваЗначений=Неопределено) экспорт

	ЭтоТаблицаЗначений=(ТипЗнч(Источник)= тип("ТаблицаЗначений"));
	ЭтоСтрокиДереваЗначений=(ТипЗнч(Источник)= тип("КоллекцияСтрокДереваЗначений"));
	Если ЭтоСтрокиДереваЗначений и КоллекцияКолонокДереваЗначений = Неопределено тогда
		Возврат Неопределено;
	Конецесли;
	
	Если ЗначениеНеЗаполнено(Реквизиты) тогда
		Если ЭтоТаблицаЗначений тогда
			НоваяТЗ = Источник.Скопировать();
	  		Возврат НоваяТЗ;
		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			Реквизиты = Новый Структура();
			Для каждого Колонка из КоллекцияКолонокДереваЗначений цикл
				Реквизиты.Вставить(Колонка.Имя);
			КонецЦикла;
		Иначе
			НоваяТЗ = Источник.Выгрузить();
	  		Возврат НоваяТЗ;
		КонецЕслИ;
	Конецесли;
	
	Если не ЭтоТаблицаЗначений  и не ЭтоСтрокиДереваЗначений тогда
		РеквизитыТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(Источник)).Реквизиты;
	Конецесли;
	
	НоваяТЗ= Новый ТаблицаЗначений();
	
	Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
 		НоваяТЗ.Колонки.Добавить("НомерСтрокиДокумента",ПолучитьОписаниеТиповЧисла(5,0));
	КонецЕсли;

	Пока НоваяТЗ.Количество()<Источник.Количество() Цикл
		Строка = НоваяТЗ.Добавить();
		Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
			Строка.НомерСтрокиДокумента = НоваяТЗ.Количество();
		КонецЕсли;
	КонецЦикла;
	
	Для каждого ТекРеквизит из Реквизиты Цикл
		ИскомыйРеквизит = ТекРеквизит.Ключ;
		НовыйРеквизит 	= ?(ТекРеквизит.Значение = Неопределено,ТекРеквизит.Ключ,ТекРеквизит.Значение);
		Если ЭтоТаблицаЗначений тогда
			ИсточникКолонка = Источник.Колонки.Найти(ИскомыйРеквизит);
		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			ИсточникКолонка = КоллекцияКолонокДереваЗначений.Найти(ИскомыйРеквизит);
		Иначе
			ИсточникКолонка = РеквизитыТабличнойЧасти.Найти(ИскомыйРеквизит);
		Конецесли;
		Если ИсточникКолонка= неопределено тогда
			//недостаточно реквизитов
			Если ФормироватьОтстутствующиеКолонки тогда
				НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			Иначе
				Возврат Неопределено;
			КонецЕсли;	
		Иначе
			НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			НоваяТЗ.ЗагрузитьКолонку(Источник.ВыгрузитьКолонку(ИскомыйРеквизит),НовыйРеквизит);
		Конецесли;
	КонецЦикла;
	
    Возврат НоваяТЗ;
КонецФункции // СформироватьТаблицуОплаты()

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт
	
	СтруктураШапкиДокумента = Новый Структура;
	СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Дата", ДокументОбъект.Дата);
	ИмяДокумента = ДокументОбъект.Метаданные().Имя;
	Для каждого Реквизит из Метаданные.Документы[ИмяДокумента].Реквизиты Цикл
		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
	КонецЦикла;

	Возврат СтруктураШапкиДокумента;
	
КонецФункции // СформироватьСтруктуруШапкиДокумента()

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений               - набор движений регистра,
//  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
//  реквизитов составного типа, которые могут содержать пустые ссылки.
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено,
	                                  ПустыеКолонкиСоставногоТипа = Неопределено) Экспорт

	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
		ПустыеКолонкиСоставногоТипа = Новый Структура;
	КонецЕсли;
	
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если (МетаИзм.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
		Если (МетаРек.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРек.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если (МетаРес.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРес.Имя);
		КонецЕсли;
	КонецЦикла;
	
	// Откопируем остальные колонки (структура таблиц совпадает).
	ПерваяКолонка = Истина;
	МассивСтрок   = Новый Массив(ТаблицаДвижений.Количество());
	Для каждого Колонка Из ТаблицаДвижений.Колонки Цикл

		ИмяКолонки = Колонка.Имя;
		Если ИмяКолонки <> "Период"
		   И ИмяКолонки <> "Активность"
		   И ИмяКолонки <> "НомерСтроки"
		   И ИмяКолонки <> ""
		   И ИмяКолонки <> "ВидДвижения" 
		   И ИмяКолонки <> "МоментВремени" Тогда
		   
			Если ИзмеренияСостТипа.Свойство(ИмяКолонки) Тогда
				ФлагКолонкиСостТипа = Истина;
			Иначе
				ФлагКолонкиСостТипа = Ложь;
			КонецЕсли;
			
			Индекс = 0;
			Для каждого СтрокаТаблицы Из ТаблицаДвижений Цикл

				Если ПерваяКолонка Тогда
					
					Если ВидДвижения = ВидДвиженияНакопления.Приход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьПриход();
					ИначеЕсли ВидДвижения = ВидДвиженияНакопления.Расход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьРасход();
					Иначе
						СтрокаДвижения = НаборДвижений.Добавить(); // Для оборотных регистров
					КонецЕсли;
					
					МассивСтрок[Индекс] = СтрокаДвижения;
					СтрокаДвижения.Период = НаборДвижений.мПериод;
					
				Иначе
					
					СтрокаДвижения = МассивСтрок[Индекс];
					
				КонецЕсли;
				
				Индекс = Индекс + 1;
				
				ЗначКолонки = СтрокаТаблицы[ИмяКолонки];
				Если ФлагКолонкиСостТипа Тогда

					Очистить = Ложь;
					Если ТипЗнч(ЗначКолонки) = Тип("Число")Тогда
						Если ЗначКолонки = 0 Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Строка") Тогда
						Если ЗначКолонки = "" Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Дата") Тогда
						Если ЗначКолонки = '00010101000000' Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ЗначКолонки = Неопределено Или ЗначКолонки.Пустая() Тогда
						Очистить = Истина;
					КонецЕсли;

					Если Очистить Тогда
						СтрокаДвижения[ИмяКолонки] = Неопределено;
					Иначе
						СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
					КонецЕсли;
				Иначе
					СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
				КонецЕсли;
				
			КонецЦикла;
			
			ПерваяКолонка = Ложь;
			
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Процедура сворачивает движения по регистру накопления
//
Процедура СвернутьТаблицуДвиженийРегистраНакопления(НаборДвижений, ТабДвижений = Неопределено, УдалятьПустыеДвижения = Ложь) Экспорт
	
	Если ТипЗнч(НаборДвижений) = Тип("Строка") Тогда
		МетаРег = Метаданные.РегистрыНакопления[НаборДвижений];
		ТаблицаДвижений = ТабДвижений;
	Иначе
		МетаРег = НаборДвижений.Метаданные();
		Если ТабДвижений = Неопределено Тогда
			ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
		Иначе
			ТаблицаДвижений = ТабДвижений;
		КонецЕсли;
	КонецЕсли;
	
	
	Если ТаблицаДвижений = Неопределено ИЛИ ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Измерения = "Период,Регистратор,Активность";
	Если МетаРег.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
		Измерения = Измерения + ",ВидДвижения";
	КонецЕсли;
	
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Измерения = Измерения + "," + МетаИзм.Имя;
	КонецЦикла;
	Для Каждого МетаИзм Из МетаРег.Реквизиты Цикл
		Измерения = Измерения + "," + МетаИзм.Имя;
	КонецЦикла;
	
	Ресурсы = "";
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Ресурсы = Ресурсы + МетаРес.Имя + ",";
	КонецЦикла;
	
	ТаблицаДвижений.Свернуть(Измерения, Ресурсы);
	
	Если УдалятьПустыеДвижения Тогда
		
		СтруктРесурсы   = Новый Структура(Ресурсы);
		МассивПустСтрок = Новый Массив;
		СтруктПоиска    = Новый Структура;
		
		Для Каждого РесурсКлюч Из СтруктРесурсы Цикл
			СтруктПоиска.Вставить( РесурсКлюч.Ключ, 0);
		КонецЦикла;
		
		МассивПустСтрок = ТаблицаДвижений.НайтиСтроки(СтруктПоиска);
		Для К = 0 По МассивПустСтрок.ВГраница() Цикл
			ТаблицаДвижений.Удалить(МассивПустСтрок[К]);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры // СвернутьТаблицуДвиженийРегистраНакопления()

// Получить движение(набор записей) для документа-объекта
//
// Параметры
//  Объект  – 	ДокументОбъект – Документ. для которого производится поиск движения
//  ТипДвижения  – Регистр<...>Менеджер – менеджер регистра, движение по которому пытаемся сформировать
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей   – набор записей для объекта
//
Функция ПолучитьДвижение(Объект, ТипДвижения, Сообщать=Ложь) Экспорт
	Движение = неопределено;
	Для каждого ТекДвижение из Объект.Движения цикл
		Если ТипЗнч(ТипДвижения.СоздатьНаборЗаписей()) = ТипЗнч(ТекДвижение) тогда
			Движение=ТекДвижение;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Сообщать и Движение = неопределено тогда
		СообщитьОбОшибке("Требуется подключение """+ТипЗНЧ(Объект)+""" к формированиям движения по регистру """+ТипЗнч(ТипДвижения)+"""!");
	КонецЕсли;
	Возврат Движение;
КонецФункции // ПолучитьДвижение()

// Получить набор записей по регистру по ссылке на документ
//
// Параметры
//  Ссылка  		– ДокументСсылка		– Ссылка на документ, для которого производится поиск движений по регистру (набора записей)
//  РегистрДвижения – Регистр<...>Менеджер	– менеджер регистра, движение по которому пытаемся обнаружить
//  ПрочитатьЗаписи - Булево 				- Прочитать существующий набор записей для документа (если документ может формировать движения по указанному регистру).
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей – Набор записей по регистру с отбором по документу,
//	 Неопределено 				в случае если документ не может формировать движений по регистру.
//
Функция ПолучитьНаборЗаписейПоСсылке(Ссылка, РегистрДвижения, ПрочитатьЗаписи = Ложь, Сообщать=Ложь) Экспорт
	Движения = неопределено;
	Если Ссылка.Метаданные().Движения.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(РегистрДвижения))) тогда
        Движения = РегистрДвижения.СоздатьНаборЗаписей();
		Движения.Отбор.Регистратор.Установить(Ссылка);
		Если ПрочитатьЗаписи тогда
			Движения.Прочитать();
		КонецЕсли;
	ИначеЕсли Сообщать тогда
			СообщитьОбОшибке("Требуется подключение документа """+Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).Представление()+""" к формированию движений по регистру """+
			СтрЗаменить(Лев(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":"))," менеджер","")+Сред(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":")+1)+
			"""!");
	КонецЕсли;
	
	Возврат Движения;
КонецФункции // ПолучитьДвижение()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОЧИХ ПОДСИСТЕМ, НЕ ИМЕЮЩИХ СВОИХ ОБЩИХ МОДУЛЕЙ

// Стандартная для данной конфигурации функция форматирования сумм
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт

	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(ЗначениеНеЗаполнено(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(ЗначениеНеЗаполнено(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если Не ЗначениеНеЗаполнено(Валюта) Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;

	Возврат РезультирующаяСтрока;

КонецФункции // ФорматСумм()

// <Описание функции>
//
// Параметры
//  Периодичность (Перечисления.Периодичность): периодичность планирования по сценарию.
//  ДатаВПериоде (Дата): произвольная дата
//
// Возвращаемое значение:
//   ДатаНачалаПериода   – ближайшая дата начала периода планирования
//
Функция ДатаНачалаПериода(ДатаВПериоде,Периодичность) Экспорт

	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат НачалоДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат НачалоНедели (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат НачалоМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат НачалоКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат НачалоГода (ДатаВПериоде);
	Иначе
		Возврат НачалоДня(ДатаВПериоде);
	КонецЕсли;

КонецФункции // ДатаНачалаПериода()

// <Описание функции>
//
// Параметры
//  Периодичность (Перечисления.Периодичность): периодичность планирования по сценарию.
//  ДатаВПериоде (Дата): произвольная дата
//
// Возвращаемое значение:
//   ДатаКонцаПериода   – ближайшая дата начала периода планирования
//
Функция ДатаКонцаПериода(ДатаВПериоде,Периодичность) Экспорт

	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат КонецДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат КонецНедели (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат КонецМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат КонецКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат КонецГода (ДатаВПериоде);
	Иначе
		Возврат КонецДня(ДатаВПериоде);
	КонецЕсли;

КонецФункции // ДатаКонцаПериода()

// <Описание процедуры>
//
//  Периодичность (Перечисления.Периодичность): пнриодичность планирования по сценарию.
//  ДатаВПериоде (Дата): произвольная дата
// 	Смещение (число): определяет направление и количество периодов, в котором сдвигается дата
//	Возвращаемое значение: дата, отстоящая от исходной на заданное количество периодов 
//
Функция ДобавитьИнтервал(ДатаПериода,Периодичность,Смещение) Экспорт

	Если Смещение=0 Тогда
		НоваяДатаПериода=ДатаПериода;	
	ИначеЕсли Периодичность=Перечисления.Периодичность.День Тогда
		НоваяДатаПериода=НачалоДня(ДатаПериода+Смещение*24*3600);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		НоваяДатаПериода=НачалоНедели(ДатаПериода+Смещение*7*24*3600);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		НоваяДатаПериода=ДобавитьМесяц(ДатаПериода,Смещение);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		НоваяДатаПериода=ДобавитьМесяц(ДатаПериода,Смещение*3);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		НоваяДатаПериода=ДобавитьМесяц(ДатаПериода,Смещение*12);
	Иначе
		НоваяДатаПериода=НачалоДня(ДатаПериода+Смещение*24*3600);
	КонецЕсли;

	Возврат НоваяДатаПериода;

КонецФункции // ДобавитьИнтервал()

// Возвращает число дней в переданном периоде
//
// Параметры
//  Периодичность – Перечисление.Периодичность элемент перечисления, 
//		для которого вычисляется количество дней
//
// Возвращаемое значение:
//   ЧислоДнейВПериоде (число)  – число дней в переданном периоде
//
Функция ЧислоДнейВПериоде(Периодичность) Экспорт

	Если Периодичность=Перечисления.Периодичность.День Тогда
		ЧислоДнейВПериоде=1;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		ЧислоДнейВПериоде=7;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		ЧислоДнейВПериоде=30;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		ЧислоДнейВПериоде=90;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		ЧислоДнейВПериоде=365;
	Иначе
		ЧислоДнейВПериоде=0;
	КонецЕсли;

	Возврат ЧислоДнейВПериоде;	

КонецФункции // ЧислоДнейВПериоде()

// Возвращает рабочую дату
//
// Возвращаемое значение:
//   Дата - рабочая дата
//
Функция ПолучитьРабочуюДату() Экспорт

#Если Клиент Тогда
	Дата = РабочаяДата;
#Иначе
	Дата = ТекущаяДата();
#КонецЕсли

	Возврат Дата;

КонецФункции // ПолучитьРабочуюДату()

// Возвращает строку, описывающую период, определяемый переданными
// датой и периодичностью.
//
// Параметры
//  ДатаВПериоде:Дата - дата из периода
//  Периодичность: Строка - строка, определяющая периодичность
//
// Возвращаемое значение:
//   СтрокаПериод: строка   – представление периода для вывода в отчетах
//
Функция ПолучитьПериодСтрокой(ДатаВПериоде,Периодичность) Экспорт

	Если Периодичность = "Год" Тогда
		ФорматДаты = "ДФ = ""гггг """"г.""""""";
	ИначеЕсли Периодичность = "Квартал" Тогда
		ФорматДаты = "ДФ = ""к"""" квартал"""" гггг """"г.""""""";
	ИначеЕсли Периодичность = "Месяц" Тогда
		ФорматДаты = "ДФ = ""ММММ гггг """"г.""""""";
	ИначеЕсли Периодичность = "Неделя" Тогда
		ФорматДаты = "ДФ = """"""Неделя с"""" дд.ММ.гггг """"""";
	ИначеЕсли Периодичность = "День" Тогда
		ФорматДаты = "ДФ = ""дд.ММ.гггг """"г.""""""";
	Иначе
		ФорматДаты = "";
	КонецЕсли;

	СтрокаПериод = "" + Формат(ДатаВПериоде, ФорматДаты);
	Если Периодичность = "Неделя" И ТипЗнч(ДатаВПериоде) = Тип("Дата") Тогда
		СтрокаПериод = СтрокаПериод + Формат(КонецНедели(ДатаВПериоде), "ДФ = """""" по """" дд.ММ.гггг """"г.""""""");
	КонецЕсли;
	
	Возврат СтрокаПериод;
	
КонецФункции // ПолучитьПериодСтрокой()

// Функция возвращает структуру с параметрами учетной политики
//
Функция ПолучитьПараметрыУчетнойПолитики(Знач КонДата, Отказ) Экспорт

	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	*
	|ИЗ
	|	РегистрСведений.УчетнаяПолитика.СрезПоследних(&КонДата) КАК УчетнаяПолитикаСрезПоследних";	

	Запрос.УстановитьПараметр("КонДата", КонДата);
	РезультатЗапроса = Запрос.Выполнить();

	СтруктураУчПолитика = Новый Структура;
	Если РезультатЗапроса.Пустой() Тогда
		СообщитьОбОшибке("Не заполнен регистр сведений ""Учетная политика"" на " + Формат(КонДата, "ДЛФ=DD"), Отказ);

	Иначе

		РезультатЗапроса = РезультатЗапроса.Выгрузить();

		Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
			СтруктураУчПолитика.Вставить(Колонка.Имя, РезультатЗапроса[0][Колонка.Имя]);
		КонецЦикла;

	КонецЕсли;

	Возврат СтруктураУчПолитика;

КонецФункции // ПолучитьПараметрыУчетнойПолитики()

// Процедура формирует движения в регистры по прочим затратам по управленческому учету
//
//	Параметры:
//		ДокСсылка - ссылка на документ
//		ТабЧасть  - таб. часть по которой формируются движения
//			В ней обязательно должны быть реквизиты "СтатьяЗатрат", "Сумма"
//			"Заказ", "Подразделение",
//			"НоменклатурнаяГруппа"
//		СтруктВал - структура с информацией о валюте
//		ВалютаРегламентированногоУчета - валюта регламентированного учета
//		ДопПараметры - структура с доп. параметрами. Возможные значения
//			"ЕстьНДС"         - признак наличия НДС в документе
//
Процедура ДвиженияПоПрочимЗатратамУпр( ДокОбъект, ТабЧасть, СтруктураШапкиДокумента, ВалютаРегламентированногоУчета, ДопПараметры = Неопределено) Экспорт

	Если Не СтруктураШапкиДокумента.ОтражатьВУправленческомУчете Тогда
		Возврат;
	КонецЕсли;

	НаборДвиженийЗатраты      = ДокОбъект.Движения.Затраты;
	ТаблицаДвиженийЗатраты    = НаборДвиженийЗатраты.Выгрузить();
	ТаблицаДвиженийЗатраты.Очистить();

	ЕстьВалютаДокумента = СтруктураШапкиДокумента.Свойство("ВалютаДокумента");
	ЕстьКурсДокумента = Ложь;
	ЕстьНДС = Ложь;
	
	// Определим доп. параметры
	ДокСтатьяЗатрат = Неопределено;
	ДокЗаказ        = Неопределено;
	ДокПодр         = Неопределено;
	ДокНоменклатура = Неопределено;
	ИмяРеквЗаказ    = "Заказ";
	ВидДвижения     = "Приход";
	
	Если Не ДопПараметры = Неопределено Тогда
		Если ДопПараметры.Свойство("ЕстьНДС") Тогда
			ЕстьНДС = ДопПараметры["ЕстьНДС"];
		КонецЕсли; 
		Если ДопПараметры.Свойство("СтатьяЗатрат") Тогда
			ДокСтатьяЗатрат = ДопПараметры["СтатьяЗатрат"];
		КонецЕсли;
		Если ДопПараметры.Свойство("Заказ") Тогда
			ДокЗаказ = ДопПараметры["Заказ"];
			Если ДокЗаказ = Неопределено Тогда
				ДокЗаказ = Документы.ЗаказПокупателя.ПустаяСсылка();
			КонецЕсли;
		КонецЕсли;
		Если ДопПараметры.Свойство("Подразделение") Тогда
			ДокПодр = ДопПараметры["Подразделение"];
		КонецЕсли;
		Если ДопПараметры.Свойство("ИмяРеквЗаказ") Тогда
			ИмяРеквЗаказ = ДопПараметры["ИмяРеквЗаказ"];
		КонецЕсли;
		Если ДопПараметры.Свойство("Номенклатура") Тогда
			ДокНоменклатура = ДопПараметры["Номенклатура"];
		КонецЕсли;
		Если ДопПараметры.Свойство("Номенклатура") Тогда
			ДокНоменклатура = ДопПараметры["Номенклатура"];
		КонецЕсли;
		Если ДопПараметры.Свойство("КурсДокумента") Тогда
			КурсДок = ДопПараметры["КурсДокумента"];
			ЕстьКурсДокумента = Истина;
		КонецЕсли;
		Если ДопПараметры.Свойство("КратностьДокумента") Тогда
			КратДок = ДопПараметры["КратностьДокумента"];
		КонецЕсли;
		
		//Адиянов<<< Начало СтатьяЗатратУпр
		Если ДопПараметры.Свойство("СтатьяЗатратУпр") Тогда
			ДокСтатьяЗатратУпр = ДопПараметры["СтатьяЗатратУпр"];
		КонецЕсли;
		//Адиянов>>> Конец СтатьяЗатратУпр
	КонецЕсли;

	Если ЕстьВалютаДокумента И НЕ ЕстьКурсДокумента Тогда
		КратДок = КратностьДокумента(ДокОбъект, ВалютаРегламентированногоУчета);
		КурсДок = КурсДокумента     (ДокОбъект, ВалютаРегламентированногоУчета);
	КонецЕсли;
	
	Если ТипЗнч(ТабЧасть) <> Тип("ТаблицаЗначений") Тогда
		ТабличнаяЧасть = ТабЧасть.Выгрузить();
	Иначе
		ТабличнаяЧасть = ТабЧасть;
	КонецЕсли;
	
	ЕстьСуммаУпр = Ложь;
	Если Не ТабличнаяЧасть.Колонки.Найти("СуммаУпр") = Неопределено Тогда
		ЕстьСуммаУпр = Истина;
	КонецЕсли;
	ЕстьНДСУпр = Ложь;
	Если Не ТабличнаяЧасть.Колонки.Найти("НДСУпр") = Неопределено Тогда
		ЕстьНДСУпр = Истина;
	КонецЕсли;
	
	//Адиянов<<< Начало СтатьяЗатратУпр
	ЕстьСтатьяЗатратУпр = Ложь;
	СтатьиЗатратУПРПустаяСсылка = Справочники.СтатьиЗатратУПР.ПустаяСсылка();
	Если Не ТабличнаяЧасть.Колонки.Найти("СтатьяЗатратУпр") = Неопределено Тогда
		ЕстьСтатьяЗатратУпр = Истина;
	КонецЕсли;
	ЕстьСтатьяЗатратУпр = ЕстьСтатьяЗатратУпр ИЛИ (ДокСтатьяЗатратУпр <> Неопределено);
	//Адиянов>>> Конец СтатьяЗатратУпр
	
	// Обход таб. части
	Для Каждого СтрокаТЧ Из ТабЧасть Цикл
		
		СтатьяЗатрат = ?(ДокСтатьяЗатрат = Неопределено, СтрокаТЧ.СтатьяЗатрат,  ДокСтатьяЗатрат);
		Заказ        = ?(ДокЗаказ        = Неопределено, СтрокаТЧ[ИмяРеквЗаказ], ДокЗаказ);
		Подр         = ?(ДокПодр         = Неопределено, СтрокаТЧ.Подразделение, ДокПодр);
		
		
		Если ЗначениеНеЗаполнено(СтатьяЗатрат) ИЛИ СтатьяЗатрат.ХарактерЗатрат = Перечисления.ХарактерЗатрат.Прочие Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЕстьСуммаУпр Тогда
			СуммаУпр = СтрокаТЧ.СуммаУпр;
			
		ИначеЕсли ЕстьВалютаДокумента Тогда
			Стоимость = СтрокаТЧ.Сумма + ?(ЕстьНДС, СтрокаТЧ.НДС, 0);
		
			СуммаУпр = ПересчитатьИзВалютыВВалюту(Стоимость, СтруктураШапкиДокумента.ВалютаДокумента,
				 СтруктураШапкиДокумента.ВалютаУправленческогоУчета,     КурсДок, 
				 СтруктураШапкиДокумента.КурсВалютыУправленческогоУчета, КратДок, 
				 СтруктураШапкиДокумента.КратностьВалютыУправленческогоУчета);
		Иначе
			СуммаУпр = СтрокаТЧ.Сумма + ?(ЕстьНДС, СтрокаТЧ.СуммаНДС, 0);
		КонецЕсли;

		Если СуммаУпр = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		//Адиянов<<< Начало СтатьяЗатратУпр 
		СтатьяЗатратУпр = СтатьиЗатратУПРПустаяСсылка;
		Если ЕстьСтатьяЗатратУпр Тогда 
			СтатьяЗатратУпр = ?(ДокСтатьяЗатратУпр = Неопределено, СтрокаТЧ.СтатьяЗатратУпр,  ДокСтатьяЗатратУпр);
			Если ЗначениеНеЗаполнено(СтатьяЗатратУпр) Тогда
				//Движение выполняем в любом случае.Но измерение СтатьяЗатратУпр не заполняем.
				//Продолжить; #УТОЧНИТЬ#
				СтатьяЗатратУпр = СтатьиЗатратУПРПустаяСсылка;
			КонецЕсли;
		КонецЕсли;
	    //Адиянов>>> Конец СтатьяЗатратУпр
		
		НоваяСтрока = ТаблицаДвиженийЗатраты.Добавить();
		НоваяСтрока.Подразделение        = Подр;
		НоваяСтрока.СтатьяЗатрат         = СтатьяЗатрат;
		НоваяСтрока.НоменклатурнаяГруппа = СтрокаТЧ.НоменклатурнаяГруппа;
		НоваяСтрока.Заказ                = Заказ;
		НоваяСтрока.Сумма                = СуммаУпр;

		//Адиянов<<< Начало СтатьяЗатратУпр
		НоваяСтрока.СтатьяЗатратУпр  = СтатьяЗатратУпр;
	    //Адиянов>>> Конец СтатьяЗатратУпр

		
	КонецЦикла;

	// Записать движения
	НаборДвиженийЗатраты.мПериод             = ДокОбъект.Дата;
	НаборДвиженийЗатраты.мТаблицаДвижений    = ТаблицаДвиженийЗатраты;

	НаборДвиженийЗатраты .ВыполнитьДвижения();
	НаборДвиженийЗатраты .Записать(Ложь);

КонецПроцедуры // ДвиженияПоПрочимЗатратамУпр()

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//		ИсхСумма - распределяемая сумма
//		МассивКоэф - массив коэффициентов распределения
//		Точность - точность округления при распределении. Необязателен.
//
//	Возврат:
//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт

	Если МассивКоэф.Количество() = 0 Или ИсхСумма = 0 Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;

	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл

		МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);

		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач   = МодульЧисла;
			ИндексМакс = К;
		КонецЕсли;

		СуммаКоэф = СуммаКоэф + МассивКоэф[К];

	КонецЦикла;

	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	МассивСумм = Новый Массив(МассивКоэф.Количество());

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		РаспрСумма    = РаспрСумма + МассивСумм[К];
	КонецЦикла;

	// Погрешности округления отнесем на коэффицент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;

	Возврат МассивСумм;

КонецФункции // РаспределитьПропорционально()

// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция ПолучитьНомерНаПечать(Документ) Экспорт

	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;

	Номер = СокрЛП(Документ.Номер);

	Префикс = "";
	Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса") Тогда

		Если НЕ ЗначениеНеЗаполнено(Документ.Организация) Тогда
			Префикс = СокрЛП(Документ.Организация.Префикс);
		КонецЕсли;

	ИначеЕсли ТипЗнч(Документ) = Тип("Структура") Тогда

		Префикс     = СокрЛП(Документ.Организация.Префикс);

	Иначе

		МетаданныеДокумента = Документ.Метаданные();

		Если ЕстьРеквизитДокумента("Организация", МетаданныеДокумента) Тогда

			Если НЕ ЗначениеНеЗаполнено(Документ.Организация) Тогда
				Префикс = СокрЛП(Документ.Организация.Префикс);
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	// удаление префикса из номера документа
	Если Найти(Номер, Префикс)=1 Тогда 
		Номер = Сред(Номер, СтрДлина(Префикс)+1);
	КонецЕсли;

	// так же, может остаться "минус" впереди
	Если Лев(Номер, 1) = "-" Тогда
		Номер = Сред(Номер, 2);
	КонецЕсли;

	// удаление ведущих нулей
	Пока Лев(Номер, 1)="0" Цикл
		Номер=Сред(Номер, 2);
	КонецЦикла;

	Возврат Номер;

КонецФункции // ПолучитьНомерНаПечать()

// Выполняет общие для всех документов действия связанные с пометкой на удаление
// счета фактуры при удалении документа, являющегося основание данного счета фактуры.
//
// Параметры:
//  ДокументОбъект  - объект документа, 
//  ВидСчетаФактуры - строка, вид счета-фактуры, по умолчанию "СчетФактураВыданный"
//
Процедура СинхронизацияПометкиНаУдалениеУСчетаФактуры(ДокументОбъект, ВидСчетаФактуры = "СчетФактураВыданный") Экспорт

	Если ДокументОбъект.ПометкаУдаления <> ДокументОбъект.Ссылка.ПометкаУдаления Тогда
		// Произошло изменение пометки на удаление
		
		//Попытаемся найти счет фактуру
		СчетФактура = НайтиПодчиненныйДокумент(ДокументОбъект.Ссылка, ВидСчетаФактуры);

		//Если потерпели неудачу, то необходимо ввести новый документ 
		Если НЕ ЗначениеНеЗаполнено(СчетФактура) Тогда
			// Есть счет фактура нужно установить для него пометку удаления
			СчетФактураОбъект = СчетФактура.ПолучитьОбъект();
			СчетФактураОбъект.УстановитьПометкуУдаления(ДокументОбъект.ПометкаУдаления);
		КонецЕсли;
		
	КонецЕсли;
		
КонецПроцедуры // СинхронизацияПометкиНаУдалениеУСчетаФактуры()

// Функция производит поиск документа заданного вида, имеющего значение реквизита "ДокументОснование", равное
// переданной ссылке.
//
// Параметры:
//  ДокументСсылка  - ссылка на документ, для которого надо найти подчиненный документ,
//  ВидСчетаФактуры - строка, вид документа, по умолчанию "СчетФактураВыданный"
//
// Возвращаемое значение:
//  Если нашли, то возвращаем ссылку, не нашли - Неопределено
//
Функция НайтиПодчиненныйДокумент(ДокументСсылка, ВидДокумента = "СчетФактураВыданный") Экспорт

	НайденныйДокумент = Неопределено;
	Если НЕ ЗначениеНеЗаполнено(ДокументСсылка) Тогда

		Запрос = Новый Запрос;

		// Установим параметры запроса
		Запрос.УстановитьПараметр("ДокументСсылка", ДокументСсылка);

		Запрос.Текст = 
		"ВЫБРАТЬ
		|	Ссылка 
		|ИЗ
		|	Документ." + ВидДокумента + "
		|
		|ГДЕ
		|	ДокументОснование = &ДокументСсылка";

		ВыборкаИзЗапроса = Запрос.Выполнить().Выбрать();

		Если ВыборкаИзЗапроса.Следующий() Тогда
			НайденныйДокумент = ВыборкаИзЗапроса.Ссылка;
		КонецЕсли;

	КонецЕсли;

	Возврат НайденныйДокумент;
	
КонецФункции // НайтиПодчиненныйДокумент()

// Проверяет облагается услуга ЕНВД, если организация является плательщиком ЕНВД.
//
// Параметры:
//  Номенклатура                         - ссылка на справочник номенклатуры, определяет услугу;
//  Организация                          - ссылка на справочник организаций, определяет организацию;
//  Дата                                 - дата проверки;
//  мОрганизацияЯвляетсяПлательщикомЕНВД - булево, признак что организация является плательщиком ЕНВД;
//
// Возвращаемое значение:
//  Истина, если услуга облагается ЕНВД, инчае - Ложь.
//
Функция ПроверитьУслугаОблагаетсяЕНВД(Номенклатура, Организация, Дата, ОрганизацияЯвляетсяПлательщикомЕНВД) Экспорт

	// Если учетная политика неопределена
	Если ОрганизацияЯвляетсяПлательщикомЕНВД = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;

	// Организаци не является плательщиком ЕНВД
	Если НЕ ОрганизацияЯвляетсяПлательщикомЕНВД Тогда
		Возврат Ложь;
	КонецЕсли;

	Если ЗначениеНеЗаполнено(Номенклатура) ИЛИ ЗначениеНеЗаполнено(Организация)Тогда
		Возврат Ложь;
	КонецЕсли;

	Флаг = Ложь;

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Дата",         Дата);
	Запрос.УстановитьПараметр("Номенклатура", Номенклатура);
	Запрос.УстановитьПараметр("Организация",  Организация);

	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	Услуги.ОблагаетсяЕНВД КАК УслугаОблагаетсяЕНВД
	|ИЗ
	|	РегистрСведений.УслугиЕНВД.СрезПоследних(&Дата, Организация = &Организация И Номенклатура = &Номенклатура) КАК Услуги
	|";

	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Флаг = Выборка.УслугаОблагаетсяЕНВД
	КонецЕсли;

	Возврат Флаг;

КонецФункции // ПроверитьУслугаОблагаетсяЕНВД()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ИНТЕРНЕТ-ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Производит проверку наличия комплекта обновления и 
// открывает форму для просмотра результатов проверки
Процедура ПроверкаНаличияКомплектаОбновлений() Экспорт

	Обозреватель = Обработки.Обозреватель.Создать();
	Форма        = Обозреватель.ПолучитьФорму("ПроверкаНаличияОбновления");

	Обозреватель.Проверить(Форма.ЭлементыФормы);

	Форма.Открыть();

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Функнция проверяет заполнения обязательных параметров для отправки сообщения
//  в отдел технической поддержки.
//
// Параметры
//  ТаблицаДанных - Таблица значений
//
// Возвращаемое значение:
//   Булево - результат корректости проверки
//
Функция ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(ТаблицаДанных, ПубликоватьСообщения = Истина) Экспорт

	ЗначениеПроверки = Истина;
	СтрокаЗаголовкаОшибки = "Не заполнены настройки для отправки сообщения.";
	
	СписокИменОбязательныхРеквизитов = Новый СписокЗначений;
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");
	СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");
	СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");
	
	Для каждого СтрокаРаздела Из ТаблицаДанных Цикл
		Для каждого ЭлементЗначения Из СтрокаРаздела.ДанныеРаздела Цикл
			Если СписокИменОбязательныхРеквизитов.НайтиПоЗначению(ЭлементЗначения.Ключ) <> Неопределено И ЗначениеНеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
				Если ПубликоватьСообщения Тогда
					СообщитьОбОшибке("Не указан """ + Лев(ЭлементЗначения.Значение[0], (СтрДлина(ЭлементЗначения.Значение[0]) - 1)) + """.",, СтрокаЗаголовкаОшибки);
				КонецЕсли; 
				ЗначениеПроверки = Ложь;
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
	Возврат ЗначениеПроверки;

КонецФункции // ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()

// Процедура формирует таблицу значений со структурой для заполнения данными
// с информацией обращения в отдел технической поддержки
//
// Параметры:
//  ТаблицаДанных - таблица значений для заполнения
//  ФормаНастройкиПараметров - общая форма настройки параметров для отправки в отдел технической поддержки
//
Процедура ЗаполнитьСтруктуруДанныхНастройкиОбращенияВОтделТехподдержкиПоУмолчанию(ТаблицаДанных, ФормаНастройкиПараметров = Неопределено) Экспорт

	// Структура данных - таблица значений:
	//  Колонки:
	//   ИмяРездела
	//   ПредставлениеРаздела
	//   ДанныеРаздела
	
	// Структура данных раздела
	//  Ключ - Имя значения настройки, как оно задано в форме настройки параметров обращения
	//  Значение - Массив значений
	// 
	// Массив значений:
	//  [0] - Представление наименования параметра для печати
	//  [1] - Значение параметра

	Если ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений") Тогда
		ТаблицаДанных = Новый ТаблицаЗначений;
	КонецЕсли;
	
	Если ТаблицаДанных.Колонки.Количество() = 0 Тогда
		ТаблицаДанных.Колонки.Добавить("ИндексСортировки"    , Новый ОписаниеТипов("Число"));
		ТаблицаДанных.Колонки.Добавить("ИмяРаздела"          , Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ПредставлениеРаздела", Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ДанныеРаздела"       , Новый ОписаниеТипов("Структура"));
	КонецЕсли; 
	
	Если ФормаНастройкиПараметров = Неопределено Тогда
		ФормаНастройкиПараметров = ПолучитьОбщуюФорму("НастройкаПараметровОбращенияВОтделТехническойПоддержки");
	КонецЕсли;
	
	Для каждого ЭлементФормы Из ФормаНастройкиПараметров.ЭлементыФормы Цикл
		
		Если ТипЗнч(ЭлементФормы) <> Тип("ПолеВвода")
		   И ТипЗнч(ЭлементФормы) <> Тип("ПолеВыбора")
		   И ТипЗнч(ЭлементФормы) <> Тип("Флажок") Тогда
			Продолжить;
		КонецЕсли;
		
		ПозицияРазделителяРаздела = Найти(ЭлементФормы.Имя, "_");
		Если ПозицияРазделителяРаздела = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяРаздела = Сред(ЭлементФормы.Имя, 1, (ПозицияРазделителяРаздела - 1));
		СтрокаРаздела = ТаблицаДанных.Найти(ИмяРаздела, "ИмяРаздела");
		Если СтрокаРаздела = Неопределено Тогда
			СтрокаРаздела = ТаблицаДанных.Добавить();
			СтрокаРаздела.ИмяРаздела           = ИмяРаздела;
			Попытка
				СтрокаРаздела.ПредставлениеРаздела = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела].Заголовок;
				СтрокаРаздела.ИндексСортировки     = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы.Индекс(ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела]);
			Исключение
				СтрокаРаздела.ПредставлениеРаздела = ИмяРаздела;
			КонецПопытки;
		КонецЕсли;
		
		МассивЗначений = Новый Массив;
		Попытка
			Если ТипЗнч(ЭлементФормы) = Тип("Флажок") Тогда
				МассивЗначений.Добавить((ЭлементФормы.Заголовок + ":"));
			Иначе
				МассивЗначений.Добавить(ФормаНастройкиПараметров.ЭлементыФормы["Надпись_" + ЭлементФормы.Имя].Заголовок);
			КонецЕсли; 
		Исключение
			МассивЗначений.Добавить(ЭлементФормы.Имя);
		КонецПопытки;
		МассивЗначений.Добавить("");
		
		СтрокаРаздела.ДанныеРаздела.Вставить(ЭлементФормы.Имя, МассивЗначений);
		
	КонецЦикла;
	
	ТаблицаДанных.Сортировать("ИндексСортировки ВОЗР");
	
КонецПроцедуры

// Функция формирует текст сообщения на линию техподдержки
//
// Параметры
//  НЕТ
//
// Возвращаемое значение:
//   Текст сообщения
//
Функция ПолучитьТекстСообщенияВОтделТехническойПоддержки() Экспорт

	ТекстВозврата = "";
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "============ Сведения об использовании ПП 1С:Предприятие 8.0 ============";
	
	ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();
	
	// Сформируем обязательный информационный раздел
	
	СистемИнфо = Новый СистемнаяИнформация;
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8.0: " + СистемИнфо.ВерсияПриложения;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;

	НомерСтрокиРаздела = 1;
	
	Если ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицыРаздела Из ТаблицаДанных Цикл
			
			СтрокаРаздела = "";
			
			Если СтрокаТаблицыРаздела.ИмяРаздела = "ПараметрыОтправкиЭлектронногоСообщения" Тогда
				Продолжить;
			КонецЕсли;
			
			Для каждого ЭлементЗначения Из СтрокаТаблицыРаздела.ДанныеРаздела Цикл
				Если ЗначениеНеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
					Продолжить;
				КонецЕсли; 
				СтрокаРаздела = СтрокаРаздела + Символы.ПС + ЭлементЗначения.Значение[0] + " " + ?(ТипЗнч(ЭлементЗначения.Значение[1]) = Тип("Булево"), ?(ЭлементЗначения.Значение[1], "Да", "Нет"), ЭлементЗначения.Значение[1]);
			КонецЦикла; 
			
			Если ЗначениеНеЗаполнено(СтрокаРаздела) Тогда
				Продолжить;
			КонецЕсли;
			
			НомерСтрокиРаздела = НомерСтрокиРаздела + 1;
			
			СтрокаРаздела = Строка(НомерСтрокиРаздела) + ". " + ВРег(СтрокаТаблицыРаздела.ПредставлениеРаздела) + СтрокаРаздела;
			
			ТекстВозврата = ТекстВозврата + Символы.ПС;
			ТекстВозврата = ТекстВозврата + Символы.ПС + СтрокаРаздела;
		
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ТекстВозврата;

КонецФункции // ПолучитьТекстСообщенияВОтделТехническойПоддержки()

Процедура УдалитьДвиженияРегистратора(ДокументОбъект, Отказ, ОчищатьКоллекциюДвижений = ИСТИНА) Экспорт
	
	// получение списка регистров, по которым существуют движения
	ТаблицаДвижений = ОпределитьНаличиеДвиженийПоРегистратору(ДокументОбъект.Ссылка);
	ТаблицаДвижений.Колонки.Добавить("НаборЗаписей");
		
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		// имя регистра передается как значение, полученное с помощью
		// функции ПолноеИмя() метаданных регистра
		ПозицияТочки = Найти(СтрокаДвижения.Имя, ".");
		ТипРегистра = Лев(СтрокаДвижения.Имя, ПозицияТочки - 1);
		ИмяРегистра = СокрП(Сред(СтрокаДвижения.Имя, ПозицияТочки + 1));
		
		ЕСли ТипРегистра = "РегистрНакопления" Тогда
			МетаданныеНабора = Метаданные.РегистрыНакопления[ИмяРегистра];
			Набор = РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
				
		ИначеЕсли ТипРегистра = "РегистрБухгалтерии" Тогда
			МетаданныеНабора = Метаданные.РегистрыБухгалтерии[ИмяРегистра];
			Набор = РегистрыБухгалтерии[ИмяРегистра].СоздатьНаборЗаписей();
				
		ИначеЕсли ТипРегистра = "РегистрСведений" Тогда
			МетаданныеНабора = Метаданные.РегистрыСведений[ИмяРегистра];
			Набор = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
				
		ИначеЕсли ТипРегистра = "РегистрРасчета" Тогда
			МетаданныеНабора = Метаданные.РегистрыРасчета[ИмяРегистра];
			Набор = РегистрыРасчета[ИмяРегистра].СоздатьНаборЗаписей();
				
		КонецЕсли;
			
		Если НЕ ПравоДоступа("Изменение", МетаданныеНабора) Тогда
			// отсутствуют права на всю таблицу регистра
			СообщитьОбОшибке("Нарушение прав доступа", Отказ, СтрокаДвижения.Имя);
			Возврат;
		КонецЕсли;
			
		Набор.Отбор.Регистратор.Установить(ДокументОбъект.Ссылка);			
		// набор не записывается сразу, чтобы не откатывать транзакцию, если впоследствии
		// выяснится, что на один из регистров не хватает прав.		
		СтрокаДвижения.НаборЗаписей = Набор;		
		
	КонецЦикла;	
	
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл		
		Попытка
			СтрокаДвижения.НаборЗаписей.Записать();
		Исключение
			// возможно «сработал» RLS или механизм даты запрета изменения
			СообщитьОбОшибке(ОписаниеОшибки(), Отказ, СтрокаДвижения.Имя);
			ВызватьИсключение "Операция не выполнена";
		КонецПопытки;
	КонецЦикла;
	
	Если ОчищатьКоллекциюДвижений Тогда
		Для Каждого Движение ИЗ ДокументОбъект.Движения Цикл
			Если Движение.Количество() > 0 Тогда
				Движение.Очистить();
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры


Функция ОтделитьРазделителем(Стр, Знач Разделитель, Режим=0)

	ПраваяЧасть         = "";
	ПозРазделителя      = Найти(Стр, Разделитель);
	ДлинаРазделителя    = СтрДлина(Разделитель);
	Если ПозРазделителя > 0 Тогда
		ПраваяЧасть	 = Сред(Стр, ПозРазделителя + ?(Режим=2, 0, ДлинаРазделителя));
		Стр          = СокрЛП(Лев(Стр, ПозРазделителя - ?(Режим=1, -ДлинаРазделителя + 1, 1)));
	КонецЕсли;

	Возврат(ПраваяЧасть);

КонецФункции // ОтделитьРазделителем()


Функция ПолучитьМассивИзСтроки(Знач Стр, Разделитель=",")    Экспорт

	Массив      = Новый Массив;
	ПраваяЧасть = ОтделитьРазделителем(Стр, Разделитель);
	
	Пока Не ПустаяСтрока(Стр) Цикл
		Массив.Добавить(СокрЛП(Стр));
		Стр         = ПраваяЧасть;
		ПраваяЧасть = ОтделитьРазделителем(Стр, Разделитель);
	КонецЦикла; 

	Возврат(Массив);
	
КонецФункции  

// Функция возвращает структуру с параметрами учетной политики (налоговый учет)
//
Функция ПолучитьПараметрыУчетнойПолитикиНалоговыйУчет(Знач КонДата, Отказ,Организация) Экспорт

	СтруктураУчПолитика = Новый Структура;
	Если НЕ ЗначениеЗаполнено(Организация) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;
		
	ИначеЕсли НЕ ЗначениеЗаполнено(КонДата) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;	
		
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	УчетнаяПолитикаСрезПоследних.*
	|ИЗ
	|	РегистрСведений.УчетнаяПолитикаНалоговыйУчет.СрезПоследних(&КонДата, Организация = &Организация) КАК УчетнаяПолитикаСрезПоследних";	

	Запрос.УстановитьПараметр("КонДата", КонДата);
	Запрос.УстановитьПараметр("Организация", Организация);
	РезультатЗапроса = Запрос.Выполнить();

	Если РезультатЗапроса.Пустой() Тогда
		СообщитьОбОшибке("Не заполнен регистр сведений ""Учетная политика (налоговый учет)"" для организации """+Организация+"""на " + Формат(КонДата, "ДЛФ=DD"), Отказ);

	Иначе

		РезультатЗапроса = РезультатЗапроса.Выгрузить();

		Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
			Если КонДата>= '20060101' И Колонка.Имя = "МоментОпределенияНалоговойБазыНДС" И РезультатЗапроса[0][Колонка.Имя] = Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОплате Тогда
				СтруктураУчПолитика.Вставить(Колонка.Имя, Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОтгрузке);
			Иначе 
				СтруктураУчПолитика.Вставить(Колонка.Имя, РезультатЗапроса[0][Колонка.Имя]);
			КонецЕсли;
			Если КонДата >= '20080101' И Колонка.Имя = "НДСНалоговыйПериод" И РезультатЗапроса[0][Колонка.Имя] = Перечисления.Периодичность.Месяц Тогда
				СтруктураУчПолитика.Вставить(Колонка.Имя, Перечисления.Периодичность.Квартал);
			Иначе 
				СтруктураУчПолитика.Вставить(Колонка.Имя, РезультатЗапроса[0][Колонка.Имя]);
			КонецЕсли;
		КонецЦикла;

	КонецЕсли;

	Возврат СтруктураУчПолитика;

КонецФункции // ПолучитьПараметрыУчетнойПолитикиНалоговыйУчет()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТОРГОВЫМ ОБОРУДОВАНИЕМ

//////////\\\Плотников
// Процедура отображает форму обработки "ТорговоеОборудование"
//
// Параметры
//  Название 	– название формы
//  Текст		- текст, отображаемый в случае ошибки
//
Процедура ОтобразитьФормуТорговоеОборудование(Название, Текст)
    Перем Форма;
	Попытка
		Форма = Обработки.ТорговоеОборудование.ПолучитьФорму("ТСДВыгрузкаДанных");
		Если Форма.Открыта() Тогда
			Форма.Активизировать();
		Иначе
			Форма.Открыть();
		КонецЕсли;
	Исключение
		СообщитьОбОшибке(Текст);
	КонецПопытки;
КонецПроцедуры // ОтобразитьФормуТорговоеОборудование()

// Процедура отображает форму выгрузки данных в ТСД
// Параметры:
//	Нет
Процедура ТСДОтобразитьФормуВыгрузкиДанных() Экспорт
	ОтобразитьФормуТорговоеОборудование(
		"ТСДВыгрузкаДанных", "Не удалось открыть форму выгрузки данных");
КонецПроцедуры

Функция ПолучитьСписокВыгружаемыхТоваров() Экспорт
	Список = Новый СписокЗначений;
	список.Добавить(Перечисления.ВидыТоваров.Диски);
	список.Добавить(Перечисления.ВидыТоваров.Шины);
	список.Добавить(Перечисления.ВидыТоваров.АКБ);
	список.Добавить(Перечисления.ВидыТоваров.Аксессуары);
	список.Добавить(Перечисления.ВидыТоваров.Прочее);
	возврат Список;
КонецФункции
