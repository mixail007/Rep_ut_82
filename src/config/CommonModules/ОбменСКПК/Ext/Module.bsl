
// процедура сохраняет в структуре настроек признак того нужно ли элемент выгружать с явным указанием типа или нет
Процедура ОпределитьНеобходимостьВыгрузкиСУказаниемТипаДанных(Знач ЭлементМетаданных, СтруктураВыгрузки)
	
	// тип следует указывать только в том случае, если он не всегда может быть одновзанчно определен
	ТребуетсяЯвноеУказаниеТипа = ЭлементМетаданных.Тип.Типы().Количество() > 1;
	СтруктураВыгрузки.Вставить("ТребуетсяЯвноеУказаниеТипа", ТребуетсяЯвноеУказаниеТипа);
	
КонецПроцедуры

// процедура сохраняет в структуре настроек признак того нужно ли элемент выгружать для группы или для элемента
Процедура ОпределитьНеобходимостьВыгрузкиДляЭлементаИГруппы(Знач ЭлементМетаданных, СтруктураВыгрузки)

	ВыгружатьДляЭлемента = (ЭлементМетаданных.Использование <> Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы);
	ВыгружатьДляГруппы = (ЭлементМетаданных.Использование <> Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента);
		
	СтруктураВыгрузки.Вставить("ВыгружатьДляЭлемента", ВыгружатьДляЭлемента);
	СтруктураВыгрузки.Вставить("ВыгружатьДляГруппы", ВыгружатьДляГруппы);
	
КонецПроцедуры

//Функция по имени объекта метаданных определяет нужно его выгружать или нет
Функция ОпределитьПоИмениОбъектаМетаданныхНужноВыгружать(Знач ИмяОбъектаМетаданных, ДеревоОпределенияВыгрузки, НайденнаяСтрока = Неопределено, ПроверятьОграниченияСхемы = Истина)
	
	Если ДеревоОпределенияВыгрузки = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	НайденнаяСтрока = ДеревоОпределенияВыгрузки.Строки.Найти(ИмяОбъектаМетаданных, "Имя");
	
	Если НайденнаяСтрока <> Неопределено Тогда
		Если ПроверятьОграниченияСхемы Тогда
			Возврат НайденнаяСтрока.ВыгружатьТолькоИзменения;		
		Иначе			
			Возврат Истина;
		КонецЕсли;
	Иначе	
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

//Функция формирует структуру для выгрузки реквизитов объекта
Функция СформироватьСтруктуруДляВыгрузкиРеквизитовОбъекта(МетаданныеОбъекта, Знач ДеревоВыгрузкиДанных, 
			Знач ОпределятьПараметрыВыгрузкиДляЭлементаИГруппы = Ложь, ПроверятьОграниченияСхемы = Истина)
	
	СтруктураРеквизитов = Новый Структура();
	
	НаборРеквизитовДляВыгрузки = ДеревоВыгрузкиДанных.Строки.Найти("Attributes", "Имя");
	
	Если НаборРеквизитовДляВыгрузки = Неопределено Тогда
		Возврат СтруктураРеквизитов;
	КонецЕсли;
	
	Для Каждого РеквизитМетаданных Из МетаданныеОбъекта.Реквизиты Цикл
		
		// сначала нужно вообще определиться выгружаем мы этот реквизит или нет		
		НужноВыгружать = ОпределитьПоИмениОбъектаМетаданныхНужноВыгружать(РеквизитМетаданных.Имя, НаборРеквизитовДляВыгрузки, ,ПроверятьОграниченияСхемы);		
			
		Если Не НужноВыгружать Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураНастроекРеквизита = Новый Структура();
		СтруктураНастроекРеквизита.Вставить("Имя", РеквизитМетаданных.Имя);
		
		Если ОпределятьПараметрыВыгрузкиДляЭлементаИГруппы Тогда
			ОпределитьНеобходимостьВыгрузкиДляЭлементаИГруппы(РеквизитМетаданных, СтруктураНастроекРеквизита);			
		КонецЕсли;
		
		ОпределитьНеобходимостьВыгрузкиСУказаниемТипаДанных(РеквизитМетаданных, СтруктураНастроекРеквизита);
		
		// добавляем структуру в реквизиты
		СтруктураРеквизитов.Вставить(СтруктураНастроекРеквизита.Имя, СтруктураНастроекРеквизита);
		
	КонецЦикла;
	
	Возврат СтруктураРеквизитов;
	
КонецФункции

//Функция формирует структуру для выгрузки реквизитов объекта
Функция СформироватьСтруктуруДляВыгрузкиТабличныхЧастейОбъекта(МетаданныеОбъекта, Знач ДеревоВыгрузкиДанных, 
			Знач ОпределятьПараметрыВыгрузкиДляЭлементаИГруппы = Ложь, ПроверятьОграниченияСхемы = Истина)
			
	СтруктураТабличныхЧастей = Новый Структура();		
			
	НаборТабличныхЧастейДляВыгрузки = ДеревоВыгрузкиДанных.Строки.Найти("TabularParts", "Имя");
	
	Если НаборТабличныхЧастейДляВыгрузки = Неопределено Тогда
		Возврат СтруктураТабличныхЧастей;
	КонецЕсли;
	
	Для Каждого ТабЧасть Из МетаданныеОбъекта.ТабличныеЧасти Цикл
		
		// сначала нужно вообще определиться выгружаем мы эту табличную часть или нет
		НайденнаяСтрокаТабЧасти = Неопределено;		
		
		НужноВыгружать = ОпределитьПоИмениОбъектаМетаданныхНужноВыгружать(ТабЧасть.Имя, НаборТабличныхЧастейДляВыгрузки, НайденнаяСтрокаТабЧасти, ПроверятьОграниченияСхемы);		
		
		Если Не НужноВыгружать Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураНастроекТабЧасти = Новый Структура();
		СтруктураНастроекТабЧасти.Вставить("Имя", ТабЧасть.Имя);
		
		Если ОпределятьПараметрыВыгрузкиДляЭлементаИГруппы Тогда
			ОпределитьНеобходимостьВыгрузкиДляЭлементаИГруппы(ТабЧасть, СтруктураНастроекТабЧасти);
		КонецЕсли;
		
		СтруктураРеквизитовТабЧасти = Новый Структура();
		// теперь все реквизиты таб части перебираем
		Для Каждого РеквизитТабЧасти Из ТабЧасть.Реквизиты Цикл
			
			// определяем нужен ли нам этот реквизит таб части			
			НужноВыгружать = ОпределитьПоИмениОбъектаМетаданныхНужноВыгружать(РеквизитТабЧасти.Имя, НайденнаяСтрокаТабЧасти, ,ПроверятьОграниченияСхемы);			
				
			Если Не НужноВыгружать Тогда
				Продолжить;
			КонецЕсли;
			
			СтруктураДанныхОдногоРеквизитаТабЧасти = Новый Структура();
			
			СтруктураДанныхОдногоРеквизитаТабЧасти.Вставить("Имя", РеквизитТабЧасти.Имя);
			ОпределитьНеобходимостьВыгрузкиСУказаниемТипаДанных(РеквизитТабЧасти, СтруктураДанныхОдногоРеквизитаТабЧасти);
			
			СтруктураРеквизитовТабЧасти.Вставить(СтруктураДанныхОдногоРеквизитаТабЧасти.Имя, СтруктураДанныхОдногоРеквизитаТабЧасти);
			
		КонецЦикла;
		
		СтруктураНастроекТабЧасти.Вставить("Реквизиты", СтруктураРеквизитовТабЧасти);
		
		// добавляем структуру данные
		СтруктураТабличныхЧастей.Вставить(СтруктураНастроекТабЧасти.Имя, СтруктураНастроекТабЧасти);
				
	КонецЦикла;		
	
	Возврат СтруктураТабличныхЧастей;
			
КонецФункции

//Функция создает структуру для дальнейшей работы выгрузки со справочником
Функция СоздатьСтруктуруДанныхДляВыгрузкиСправочника(МетаданныеОбъекта, Знач ДеревоВыгрузкиДанных, ПроверятьОграниченияСхемы = Истина)
	
	Если ДеревоВыгрузкиДанных = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураДанныхВыгрузки = Новый Структура();
	
	СтруктураДанныхВыгрузки.Вставить("Имя", МетаданныеОбъекта.Имя);
	
	СтруктураДанныхВыгрузки.Вставить("ВыгружатьПризнакГруппы", МетаданныеОбъекта.Иерархический
		И МетаданныеОбъекта.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов);
		
	КоличествоВладельцев = МетаданныеОбъекта.Владельцы.Количество();	
		
	СтруктураДанныхВыгрузки.Вставить("ВыгружатьВладельцев", КоличествоВладельцев > 0);	
		
	СтруктураДанныхВыгрузки.Вставить("ВыгружатьРодителя", МетаданныеОбъекта.Иерархический);
	СтруктураДанныхВыгрузки.Вставить("ВыгружатьКод", МетаданныеОбъекта.ДлинаКода > 0);
	СтруктураДанныхВыгрузки.Вставить("ВыгружатьНаименование", МетаданныеОбъекта.ДлинаНаименования > 0);
	
	//РЕКВИЗИТЫ
	СтруктураРеквизитов = СформироватьСтруктуруДляВыгрузкиРеквизитовОбъекта(МетаданныеОбъекта, ДеревоВыгрузкиДанных,Истина,ПроверятьОграниченияСхемы);
	СтруктураДанныхВыгрузки.Вставить("Реквизиты", СтруктураРеквизитов);
	
	// ТАБЛИЧНЫЕ ЧАСТИ
	СтруктураТабличныхЧастей = СформироватьСтруктуруДляВыгрузкиТабличныхЧастейОбъекта(МетаданныеОбъекта, ДеревоВыгрузкиДанных,Истина,ПроверятьОграниченияСхемы);
	СтруктураДанныхВыгрузки.Вставить("ТабличныеЧасти", СтруктураТабличныхЧастей);
		
	Возврат СтруктураДанныхВыгрузки;
	
КонецФункции

//Функция создает структуру для дальнейшей работы выгрузки со справочником
Функция СоздатьСтруктуруДанныхДляВыгрузкиДокумента(МетаданныеОбъекта, Знач ДеревоВыгрузкиДанных, ПроверятьОграниченияСхемы = Истина)
	
	Если ДеревоВыгрузкиДанных = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураДанныхВыгрузки = Новый Структура();
	
	СтруктураДанныхВыгрузки.Вставить("Имя", МетаданныеОбъекта.Имя);
	СтруктураДанныхВыгрузки.Вставить("ВыгружатьНомер", МетаданныеОбъекта.ДлинаНомера > 0);
	СтруктураДанныхВыгрузки.Вставить("ВыгружатьПроведение", МетаданныеОбъекта.Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить);
	
	//РЕКВИЗИТЫ
	СтруктураРеквизитов = СформироватьСтруктуруДляВыгрузкиРеквизитовОбъекта(МетаданныеОбъекта, ДеревоВыгрузкиДанных,, ПроверятьОграниченияСхемы);
	СтруктураДанныхВыгрузки.Вставить("Реквизиты", СтруктураРеквизитов);
	
	// ТАБЛИЧНЫЕ ЧАСТИ
	СтруктураТабличныхЧастей = СформироватьСтруктуруДляВыгрузкиТабличныхЧастейОбъекта(МетаданныеОбъекта, ДеревоВыгрузкиДанных,, ПроверятьОграниченияСхемы);
	СтруктураДанныхВыгрузки.Вставить("ТабличныеЧасти", СтруктураТабличныхЧастей);
		
	Возврат СтруктураДанныхВыгрузки;
		
КонецФункции

// процедура выгружает значение реквизита объекта в записьXML
Процедура ЗаписатьЗначениеРеквизита(ЗаписьXML, Знач ЗначениеРеквизита, Знач СтруктураВыгрузки)
	
	ТипВыгрузкиДанных = ?(СтруктураВыгрузки.ТребуетсяЯвноеУказаниеТипа, НазначениеТипаXML.Явное, НазначениеТипаXML.НеЯвное);
	ЗаписатьXML(ЗаписьXML, ЗначениеРеквизита, СтруктураВыгрузки.Имя, ТипВыгрузкиДанных);
	
КонецПроцедуры

//функция по флагам выгрузки объекта для элемента или для группы  определяет нужно ли производить выгрузку или нет
Функция ОпределитьНужноПроводитьВыгрузкуДляГруппыИЭлемента(Знач ЭтоГруппа, СтруктураДляВыгрузки)
	
	Возврат (ЭтоГруппа И СтруктураДляВыгрузки.ВыгружатьДляГруппы)
			ИЛИ (НЕ ЭтоГруппа И СтруктураДляВыгрузки.ВыгружатьДляЭлемента);	
			
КонецФункции
		
//процедура выгружает все реквизиты объекта
Процедура ВыгрузитьРеквизитыОбъекта(СтруктураДляВыгрузки, ДанныеЭлемента, ЗаписьXML, Знач ЭтоГруппа = Неопределено)
	
	Для Каждого РеквизитВыгрузки Из СтруктураДляВыгрузки.Реквизиты Цикл
		
		Если ЭтоГруппа <> Неопределено Тогда
			
			// опередляем нужно ли выгружать реквизит			
			
			НужнаВыгрузка = ОпределитьНужноПроводитьВыгрузкуДляГруппыИЭлемента(ЭтоГруппа, РеквизитВыгрузки.Значение);
			
			Если НЕ НужнаВыгрузка Тогда
				Продолжить;
			КонецЕсли;
		
		КонецЕсли;
			
		ЗаписатьЗначениеРеквизита(ЗаписьXML, ДанныеЭлемента[РеквизитВыгрузки.Значение.Имя], РеквизитВыгрузки.Значение);
		
	КонецЦикла;
	
КонецПроцедуры

//процедура выгружает все табличные части объекта
Процедура ВыгрузитьТабличныеЧастиОбъекта(СтруктураДляВыгрузки, ДанныеЭлемента, ЗаписьXML, Знач ЭтоГруппа = Неопределено)
	
	// табличные части смотрим
	Для Каждого ТабличнаяЧасть Из СтруктураДляВыгрузки.ТабличныеЧасти Цикл
		
		НужнаВыгрузка = (ТабличнаяЧасть.Значение.Реквизиты.Количество() > 0);
		Если ЭтоГруппа <> Неопределено Тогда
			
			// опередляем нужно ли выгружать табличную часть			
			НужнаВыгрузка = НужнаВыгрузка 
				И ОпределитьНужноПроводитьВыгрузкуДляГруппыИЭлемента(ЭтоГруппа, ТабличнаяЧасть.Значение);
			
		КонецЕсли;
		
		ЗаписьXML.ЗаписатьНачалоЭлемента(ТабличнаяЧасть.Ключ);
		
		// если выгрузка не нужна то реквизиты не выгружаем
		Если НЕ НужнаВыгрузка Тогда
				
			ЗаписьXML.ЗаписатьКонецЭлемента(); // имя таб части
			Возврат;
				
		КонецЕсли;
			
		// реквизиты из таб частей выгружаем	
		Для Каждого СтрокаТабЧасти Из ДанныеЭлемента[ТабличнаяЧасть.Ключ] Цикл
				
			ЗаписьXML.ЗаписатьНачалоЭлемента("Row");
				
			Для Каждого РеквизитТабЧасти Из ТабличнаяЧасть.Значение.Реквизиты Цикл
					
				ЗаписатьЗначениеРеквизита(ЗаписьXML, СтрокаТабЧасти[РеквизитТабЧасти.Ключ], РеквизитТабЧасти.Значение);	
					
			КонецЦикла;
					
			ЗаписьXML.ЗаписатьКонецЭлемента(); // row
				
		КонецЦикла;
			
		ЗаписьXML.ЗаписатьКонецЭлемента(); // имя таб части
		
	КонецЦикла;
		
КонецПроцедуры

// процедура Записывает в XML часть данных для справочника
Процедура ЗаписатьИнформациюОДанныхЭлементаСправочника(ЗаписьXML, СтруктураДляВыгрузки, ДанныеЭлемента)
	
	ЗаписьXML.ЗаписатьНачалоЭлемента("CatalogObject." + СтруктураДляВыгрузки.Имя);	
	
	ЗаписатьXML(ЗаписьXML, ДанныеЭлемента.Ссылка, "Ref", НазначениеТипаXML.Неявное); // Ссылка
	
	Если СтруктураДляВыгрузки.ВыгружатьПризнакГруппы Тогда
		
		ЗаписатьXML(ЗаписьXML, ДанныеЭлемента.ЭтоГруппа, "IsFolder", НазначениеТипаXML.Неявное); // ЭтоГруппа
		
	КонецЕсли;
	
	ЗаписатьXML(ЗаписьXML, ДанныеЭлемента.ПометкаУдаления, "DeletionMark"); // ПометкаУдаления	
	
	Если СтруктураДляВыгрузки.ВыгружатьВладельцев Тогда
		
		ЗаписатьXML(ЗаписьXML, ДанныеЭлемента.Владелец, "Owner", НазначениеТипаXML.Явное); // Владелец	

	КонецЕсли;
    	
	// родитель
	Если СтруктураДляВыгрузки.ВыгружатьРодителя Тогда
		
		ЗаписатьXML(ЗаписьXML, ДанныеЭлемента.Родитель, "Parent", НазначениеТипаXML.НеЯвное); 
		
	КонецЕсли;
	
	// код
	Если СтруктураДляВыгрузки.ВыгружатьКод Тогда
		
		ЗаписатьXML(ЗаписьXML, ДанныеЭлемента.Код, "Code", НазначениеТипаXML.Неявное);
		
	КонецЕсли;
	
	// Наименование
	Если СтруктураДляВыгрузки.ВыгружатьНаименование Тогда
		
		ЗаписатьXML(ЗаписьXML, ДанныеЭлемента.Наименование, "Description", НазначениеТипаXML.Неявное);
		
	КонецЕсли;	
	
	// реквизиты
	ВыгрузитьРеквизитыОбъекта(СтруктураДляВыгрузки, ДанныеЭлемента, ЗаписьXML, ДанныеЭлемента.ЭтоГруппа);
	// табличные части
	ВыгрузитьТабличныеЧастиОбъекта(СтруктураДляВыгрузки, ДанныеЭлемента, ЗаписьXML, ДанныеЭлемента.ЭтоГруппа);
			
	ЗаписьXML.ЗаписатьКонецЭлемента();
	
КонецПроцедуры

// процедура Записывает в XML часть данных для документа
Процедура ЗаписатьинформациюОДанныхДокумента(ЗаписьXML, СтруктураДляВыгрузки, ДанныеДокумента)
	
	ЗаписьXML.ЗаписатьНачалоЭлемента("DocumentObject." + СтруктураДляВыгрузки.Имя);	
	
	ЗаписатьXML(ЗаписьXML, ДанныеДокумента.Ссылка, "Ref", НазначениеТипаXML.Неявное); // Ссылка
	ЗаписатьXML(ЗаписьXML, ДанныеДокумента.ПометкаУдаления, "DeletionMark"); // ПометкаУдаления
	ЗаписатьXML(ЗаписьXML, ДанныеДокумента.Дата, "Date"); // Дата
	
	Если СтруктураДляВыгрузки.ВыгружатьНомер Тогда
		
		ЗаписатьXML(ЗаписьXML, ДанныеДокумента.Номер, "Number"); // Номер
		
	КонецЕсли;

	Если СтруктураДляВыгрузки.ВыгружатьПроведение Тогда
		
		ЗаписатьXML(ЗаписьXML, ДанныеДокумента.Проведен, "Posted"); // Проведение
		
	КонецЕсли;
	
	// реквизиты
	ВыгрузитьРеквизитыОбъекта(СтруктураДляВыгрузки, ДанныеДокумента, ЗаписьXML);
	// табличные части
	ВыгрузитьТабличныеЧастиОбъекта(СтруктураДляВыгрузки, ДанныеДокумента, ЗаписьXML);
			
	ЗаписьXML.ЗаписатьКонецЭлемента();	
	
КонецПроцедуры

// процедура записывает в XML секцию очистки данных в соответствии с заданными настройками обмена
Процедура ЗаписатьСекциюОчисткиДанных(ЗаписьXML, ДеревоСхемыОбменаДанными)
			
	ВеткиКлассов = ДеревоСхемыОбменаДанными.Строки[0].Строки;	
	НайденнаяСтрока = ВеткиКлассов.Найти(Истина, "ОчищатьДанные", Истина);
	
	// Если ничего не подлежит очистке, то секцию очистки данных в пакет обмена не включаем
	Если НайденнаяСтрока = Неопределено Тогда 		
		Возврат;
	КонецЕсли;	
	
	ЗаписьXML.ЗаписатьНачалоЭлемента("ClearData");
	
	Для Каждого ВеткаКласса из ВеткиКлассов Цикл
		
		ИмяКласса = ВеткаКласса.Имя;
		Если ИмяКласса = "Catalogs" Тогда
			ИмяТипаТаблицы = "Catalog";
		ИначеЕсли ИмяКласса = "Documents" Тогда
			ИмяТипаТаблицы = "Document";
		ИначеЕсли ИмяКласса = "InformationRegisters" Тогда
			ИмяТипаТаблицы = "InformationRegister";
		КонецЕсли;	
		
		Для Каждого Объект из ВеткаКласса.Строки Цикл
			
			Если Объект.ОчищатьДанные Тогда // Для объектов, подлежащих очистке, запишем команды удаления
				
				ЗаписьXML.ЗаписатьНачалоЭлемента(ИмяТипаТаблицы + "." + Объект.Имя);
				ЗаписьXML.ЗаписатьНачалоЭлемента("Filter");
				
				Если ИмяКласса = "InformationRegisters" Тогда
					ВеткаРеквизитов = Объект;
				Иначе	
					ВеткаРеквизитов = Объект.Строки.Найти("Attributes", "Имя");
				Конецесли;	
                				
				Если ВеткаРеквизитов <> Неопределено Тогда
					
					Для Каждого СтрокаРеквизита из ВеткаРеквизитов.Строки Цикл
						
						// Для элемента отбора, соответствующего текущему реквизиту, запишем фильтр очистки
						Для Каждого ЭлементОтбора из СтрокаРеквизита.УсловиеОчистки Цикл
							
							Если ЭлементОтбора.Использование Тогда
								
								ТребуетсяЯвноеУказаниеТипа = СтрокаРеквизита.ОписаниеТипов.Типы().Количество() > 1;
								УказаниеТипа = ?(ТребуетсяЯвноеУказаниеТипа, НазначениеТипаXML.Явное, НазначениеТипаXML.Неявное);
								
								ЗаписьXML.ЗаписатьНачалоЭлемента(ЭлементОтбора.Имя);
								
								Если ЭлементОтбора.ВидСравнения = ВидСравнения.Интервал Тогда
									ЗаписатьXML(ЗаписьXML, "", "ValueFrom", УказаниеТипа);
									ЗаписатьXML(ЗаписьXML, "", "ValueTo", УказаниеТипа);
								Иначе							
									ЗаписатьXML(ЗаписьXML, ЭлементОтбора.Значение, "Value", УказаниеТипа);							
								КонецЕсли;
								
								ЗаписатьXML(ЗаписьXML, СтрЗаменить(Строка(ЭлементОтбора.ВидСравнения)," ",""), "ComparisonType", НазначениеТипаXML.Неявное);						
								
								ЗаписьXML.ЗаписатьКонецЭлемента(); // Для тега с именем реквизита		
								
							КонецЕсли;
							
						КонецЦикла;
						
					КонецЦикла;
					
				КонецЕсли;
				
				ЗаписьXML.ЗаписатьКонецЭлемента(); // Для тега Filter
				
				ЗаписьXML.ЗаписатьКонецЭлемента(); // Для тега с именем очищаемой таблицы
								
			КонецЕсли;
			
		КонецЦикла;
	
	КонецЦикла;
	
	ЗаписьXML.ЗаписатьКонецЭлемента(); // Для тега ClearData	
	
КонецПроцедуры	

// процедура записывает в XML данные по тем объектам, которые не входят в состав плана обмена
Процедура ЗаписатьИнформациюОбОбъектахБезРегистрацииИзменений(Пользователь, ЗаписьXML, ДеревоСхемыОбменаДанными, СтруктураСтрокКлассов, СтруктураПараметровОбменаДанными)
	
	Если СтруктураПараметровОбменаДанными.ПолучатьОстаткиВВидеТаблицыЗначений Тогда
		// Запишем таблицу остатков
		ЗаписьXML.ЗаписатьНачалоЭлемента("PersistentDataList");
		//КПКубрал+
		//XMLСтрокаТаблицыостатков = ПолучитьОстаткиВВидеТЗ();
		//КПКубрал-
		
		ЗаписьXML.ЗаписатьНачалоЭлемента("ТаблицаОстатковНоменклатуры");		
		//КПКубрал+
		//ЗаписьXML.ЗаписатьТекст(XMLСтрокаТаблицыостатков);
		//КПКубрал-
		ЗаписьXML.ЗаписатьКонецЭлемента(); // ТаблицаОстатковНоменклатуры
		
		ЗаписьXML.ЗаписатьКонецЭлемента(); // PersistentDataList
		
	КонецЕсли;	
		
	
	// Запись констант
	Если СтруктураСтрокКлассов.Константы <> Неопределено Тогда
		Для Каждого Константа из СтруктураСтрокКлассов.Константы.Строки Цикл
			Если (Константа.Выгружать) И (Не Константа.ВыгружатьТолькоИзменения) Тогда  
				Объект = Константы[Константа.Имя].СоздатьМенеджерЗначения();
				Объект.Прочитать();
				ЗаписатьXML(ЗаписьXML, Объект);
			Конецесли;
		КонецЦикла;
	КонецЕсли;
	
	// Запись справочников
	Если СтруктураСтрокКлассов.Справочники <> Неопределено Тогда
		Для Каждого Справочник из СтруктураСтрокКлассов.Справочники.Строки Цикл
			Если (Справочник.Выгружать) И (Не Справочник.ВыгружатьТолькоИзменения) Тогда  
				РезультатЗапросаПоСправочникам = ВыполнитьЗапрос("Справочник." + Справочник.Имя,Справочник);
				ЗаписатьДанныеВПакетОбмена(ЗаписьXML, РезультатЗапросаПоСправочникам, Справочник.СтруктураОграничений, "Справочник");
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Запись документов
	Если СтруктураСтрокКлассов.Документы <> Неопределено Тогда
		Для Каждого Документ из СтруктураСтрокКлассов.Документы.Строки Цикл
			Если (Документ.Выгружать) И (Не Документ.ВыгружатьТолькоИзменения) Тогда 
				РезультатЗапросаПоДокументам = ВыполнитьЗапрос("Документ." + Документ.Имя,Документ);
				ЗаписатьДанныеВПакетОбмена(ЗаписьXML, РезультатЗапросаПоДокументам, Документ.СтруктураОграничений, "Документ");
			КонецЕсли;	
		КонецЦикла;
	КонецЕсли;	
	
	// Запись регистров сведений
	Если СтруктураСтрокКлассов.РегистрыСведений <> Неопределено Тогда
		Для Каждого РегистрСведений из СтруктураСтрокКлассов.РегистрыСведений.Строки Цикл
			
			Если (РегистрСведений.Выгружать) И (Не РегистрСведений.ВыгружатьТолькоИзменения) Тогда				
				
				// Для штрихкодов - отдельная проверка	
				Если РегистрСведений.Имя = "ШтрихкодыДляМобильныхПриложений" Тогда
					Если Не СтруктураПараметровОбменаДанными.ПолучатьШтрихкоды Тогда
						Продолжить;
					КонецЕсли;					
				КонецЕсли;
				
				// Для остатков - отдельная проверка	
				Если РегистрСведений.Имя = "ОстаткиНаСкладахДляМобильныхИБ" Тогда
					Если Не СтруктураПараметровОбменаДанными.ПолучатьОстаткиВВидеРегистраСведений Тогда
						Продолжить;
					КонецЕсли;					
				КонецЕсли;

				
				НаборЗаписей = РегистрыСведений[РегистрСведений.Имя].СоздатьНаборЗаписей();
				
				Для Каждого ВеткаИзмерений из РегистрСведений.Строки Цикл
					
					Отбор = ВеткаИзмерений.УсловиеОтбора;
					Для Каждого ЭлементОтбора из Отбор Цикл
						УстанавливаемыйЭлементОтбора = НаборЗаписей.Отбор.Найти(ЭлементОтбора.Имя);
						Если УстанавливаемыйЭлементОтбора<>Неопределено Тогда
							УстанавливаемыйЭлементОтбора.Установить(ЭлементОтбора.Значение, ЭлементОтбора.Использование);							
						КонецЕсли;	
					КонецЦикла;
					
				КонецЦикла;				
				
				Если РегистрСведений.Имя = "ОстаткиНаСкладахДляМобильныхИБ" Тогда
					УстанавливаемыйЭлементОтбора = НаборЗаписей.Отбор.Найти("Пользователь");
					Если УстанавливаемыйЭлементОтбора<>Неопределено Тогда
						УстанавливаемыйЭлементОтбора.Установить(Пользователь, Истина);							
					КонецЕсли;
				КонецЕсли;
				
				НаборЗаписей.Прочитать();
				
				Если НаборЗаписей.Количество()>0 Тогда
					ЗаписатьXML(ЗаписьXML, НаборЗаписей);
				КонецЕсли;					
				
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
		
КонецПроцедуры	

// Выполняет запрос по таблице данных с учетом переданных настроек
// Возвращаемое значение - Результат запроса
Функция ВыполнитьЗапрос(ИмяТаблицы, Объект)
	
	ПостроительЗапроса = Новый ПостроительЗапроса();
	ПостроительЗапроса.Текст = "ВЫБРАТЬ Ссылка ИЗ " + ИмяТаблицы;					
	ПостроительЗапроса.ЗаполнитьНастройки();
	
	ДоступныеПоля = ПостроительЗапроса.ДоступныеПоля;
	ПостроительЗапроса.ВыбранныеПоля.Очистить();
	
	СтрокиОбъекта = Объект.Строки;
		
	ПостроительЗапроса.ВыбранныеПоля.Добавить("Ссылка", "Ссылка");
    		
	// Добавим отбор в соответствии с заданными настройками
	
	ВеткаРеквизитов = СтрокиОбъекта.Найти("Attributes", "Имя");
	Если ВеткаРеквизитов <> Неопределено Тогда
		Для Каждого Реквизит Из ВеткаРеквизитов.Строки Цикл
			Отбор = Реквизит.УсловиеОтбора;
			Для Каждого ЭлементОтбора Из Отбор Цикл
				Если ЭлементОтбора.Использование Тогда
					ДобавитьЭлементОтбора(ПостроительЗапроса, ЭлементОтбора);
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;	
		
	ПостроительЗапроса.Выполнить();
	
	Возврат ПостроительЗапроса.Результат;
	
КонецФункции	

// Процедура выполняет добавление элемента в отбор построителя запроса
Процедура ДобавитьЭлементОтбора(ПостроительЗапроса, ЭлементОтбора)
	
    Если ПостроительЗапроса.ДоступныеПоля.Найти(ЭлементОтбора.Имя) = Неопределено Тогда
		Поле = ПостроительЗапроса.ДоступныеПоля.Добавить(ЭлементОтбора.Имя, ЭлементОтбора.Имя);
		Поле.ТипЗначения = ПостроительЗапроса.ДоступныеПоля.Ссылка.Поля[ЭлементОтбора.Имя].ТипЗначения;
		Поле.Отбор = Истина;
	КонецЕсли;	
	
	ЭлементОтбораПостроителя = ПостроительЗапроса.Отбор.Добавить("Ссылка." + ЭлементОтбора.Имя,ЭлементОтбора.Имя);
	ЭлементОтбораПостроителя.ВидСравнения = ЭлементОтбора.ВидСравнения;
	ЭлементОтбораПостроителя.Значение = ЭлементОтбора.Значение;
	ЭлементОтбораПостроителя.ЗначениеС = ЭлементОтбора.ЗначениеС;
	ЭлементОтбораПостроителя.ЗначениеПо = ЭлементОтбора.ЗначениеПо;	
	ЭлементОтбораПостроителя.Использование = Истина;
	
КонецПроцедуры	

//Записывает данные, переданные как результата запроса, в пакет обмена
Процедура ЗаписатьДанныеВПакетОбмена(ЗаписьXML,РезультатЗапроса,СтруктураОграничений, ВидОбъекта)
	
	ВыборкаИзРезультатаЗапроса = РезультатЗапроса.Выбрать();
	Пока ВыборкаИзРезультатаЗапроса.Следующий() Цикл
		Если ВидОбъекта = "Справочник" Тогда
			ЗаписатьИнформациюОДанныхЭлементаСправочника(ЗаписьXML, СтруктураОграничений, ВыборкаИзРезультатаЗапроса.Ссылка);
		ИначеЕсли ВидОбъекта = "Документ" Тогда	
			ЗаписатьИнформациюОДанныхДокумента(ЗаписьXML, СтруктураОграничений, ВыборкаИзРезультатаЗапроса.Ссылка);		
		КонецЕсли;	
	КонецЦикла;
	
КонецПроцедуры

//Функция загрузки узла из XML файла
Функция СоздатьУзелНаВетке(ТекущаяВетка, ДеревоОбработки) Экспорт
	
	Если ТекущаяВетка = Неопределено Тогда
		Возврат ДеревоОбработки.Строки.Добавить();
	Иначе
		Возврат ТекущаяВетка.Строки.Добавить();
	КонецЕсли;
	
КонецФункции

//процедура считывает элементы в дерево из XML
Процедура СчитатьЭлементыXMLВДерево(XMLПоток, ДеревоФайла, УровеньВложенности = 0) Экспорт
	
	ТекущаяВетка = Неопределено;
	
	Попытка
		
		Пока XMLПоток.Прочитать() Цикл
			
			Если XMLПоток.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
				УровеньВложенности = УровеньВложенности + 1;
				
				Если ДеревоФайла <> Неопределено Тогда
					
					ТекущаяВетка = СоздатьУзелНаВетке(ТекущаяВетка, ДеревоФайла);
					ТекущаяВетка.Имя = XMLПоток.Имя;
																		
					Пока XMLПоток.ПрочитатьАтрибут() Цикл
						АтрибутВДереве = СоздатьУзелНаВетке(ТекущаяВетка, ДеревоФайла);
						АтрибутВДереве.Имя =  XMLПоток.Имя;
						АтрибутВДереве.Значение =  XMLПоток.Значение;
					КонецЦикла;
				
				КонецЕсли;
												
			ИначеЕсли XMLПоток.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
				
				УровеньВложенности = УровеньВложенности - 1;
				
				Если УровеньВложенности <= 0 Тогда
					XMLПоток.Прочитать();
					Возврат;
				КонецЕсли;
				
				Если ТекущаяВетка <> Неопределено Тогда
					ТекущаяВетка = ТекущаяВетка.Родитель;
				КонецЕсли;
				
			Иначе
				
				Если ДеревоФайла <> Неопределено Тогда
					
					АтрибутВДереве = СоздатьУзелНаВетке(ТекущаяВетка, ДеревоФайла);
					АтрибутВДереве.Имя =  "";
					АтрибутВДереве.Значение =  XMLПоток.Значение;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
	Исключение
		
		СообщитьОбОшибке("Возникла ошибка при чтении файла: " + ОписаниеОшибки());
		Возврат;
		
	КонецПопытки;
	
КонецПроцедуры

//Функция создает заготовку дерева для считывания данных из XML
Функция СоздатьЗаготовкуДереваДляСчитыванияданныхИзXML() Экспорт
	
	ДеревоФайла = Новый ДеревоЗначений;
	ДеревоФайла.Колонки.Добавить("Имя");
	ДеревоФайла.Колонки.Добавить("Синоним");
	ДеревоФайла.Колонки.Добавить("Значение");
	
	Возврат ДеревоФайла;
	
КонецФункции

//Функция создания дерева по XML файлу
Функция ПолучитьДеревоНастроекИзСтроки(Знач СтрокаДляЧтенияПараметров) Экспорт
	
	XMLПоток = Новый ЧтениеXML();
		
	Попытка
		XMLПоток.УстановитьСтроку(СтрокаДляЧтенияПараметров);
	Исключение
		СообщитьОбОшибке("Во время чтения настроек обмена произошла ошибка: " + ОписаниеОшибки());
		Возврат Неопределено;
	КонецПопытки;
	
	ДеревоФайла = СоздатьЗаготовкуДереваДляСчитыванияданныхИзXML();
	ДеревоФайла.Колонки.Добавить("СтруктураОграничений");
	//ДеревоФайла.Колонки.Добавить("ВыгружатьТолькоИзменения", Новый ОписаниеТипов("Булево"));
	
	СчитатьЭлементыXMLВДерево(XMLПоток, ДеревоФайла);
	
	Возврат ДеревоФайла;
	
КонецФункции

// функция получает значение узла дерева
Функция ПолучитьЗначениеУзлаДерева(СтрокаДерева) Экспорт 
	
	Если СтрокаДерева = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтрокаСПустымИмененм = СтрокаДерева.Строки.Найти("", "Имя", Ложь);
	Если СтрокаСПустымИмененм = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат СтрокаСПустымИмененм.Значение;
	
КонецФункции

// функция получает тип значения узла
Функция ПолучитьТипУзлаДерева(СтрокаДерева) Экспорт 
	
	Если СтрокаДерева = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	СтрокаОпределенияТипа = СтрокаДерева.Строки.Найти("xsi:type", "Имя", Ложь);
	Если СтрокаОпределенияТипа = Неопределено Тогда
		// может там неопределено хранится
		СтрокаОпределенияТипа = СтрокаДерева.Строки.Найти("xsi:nil", "Имя", Ложь);
		
		//найдена строка с описанием NIL не NIL
		Если СтрокаОпределенияТипа <> Неопределено Тогда
			
			Если ПолучитьБулевыйТипПоСтроковомуЗначениюXML(Врег(СтрокаОпределенияТипа.Значение)) = Истина Тогда
				Возврат "XSI:NIL";
			Иначе
				// неизвестно что это
				Возврат "";
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Врег(СтрокаОпределенияТипа.Значение);
	
КонецФункции

//Функция формирует структуру ограничений для одной ветки метаданных
Функция СформироватьСтруктуруОграниченийДляВеткиМетаданных(Знач КореньДереваОграничений, Знач ИмяПараметраМетаданных, ПроверятьОграниченияСхемы = Истина) Экспорт
	
	Если ИмяПараметраМетаданных = "CATALOGS" Тогда 
		
		МетаданныеОбъекта = Метаданные.Справочники.Найти(КореньДереваОграничений.Имя);
				
	ИначеЕсли ИмяПараметраМетаданных = "DOCUMENTS" Тогда
		
		МетаданныеОбъекта = Метаданные.Документы.Найти(КореньДереваОграничений.Имя);
		
	Иначе
		МетаданныеОбъекта = Неопределено;
	КонецЕсли;
	
	// не нашли среди метаданных объект
	Если МетаданныеОбъекта = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ИмяПараметраМетаданных = "CATALOGS" Тогда
		
		СтруктураОграничений = СоздатьСтруктуруДанныхДляВыгрузкиСправочника(МетаданныеОбъекта, КореньДереваОграничений, ПроверятьОграниченияСхемы);
		
	ИначеЕсли ИмяПараметраМетаданных = "DOCUMENTS" Тогда
		
		СтруктураОграничений = СоздатьСтруктуруДанныхДляВыгрузкиДокумента(МетаданныеОбъекта, КореньДереваОграничений, ПроверятьОграниченияСхемы);
		
	КонецЕсли;
	
	Возврат СтруктураОграничений;
	
КонецФункции

// функция создает дерево в котором хранится информация по объектам подлежащим выгрузке
Функция СоздатьДеревоОбъектовДляМетаданныхПодлежащихВыгрузке(Знач СтрокаЗначенийНастроекОбмена, СтрокаСообщенияОбОшибке, ВключатьПодчиненныеВетвиОбъектов = Ложь) Экспорт
	
	ДеревоПараметровВыгрузки = ПолучитьДеревоНастроекИзСтроки(СтрокаЗначенийНастроекОбмена);
		
	// дерево создано
	Если ДеревоПараметровВыгрузки = Неопределено Тогда
		
		СтрокаСообщенияОбОшибке = "Не найдены данные ограничений для выгрузки!";			
		Возврат Неопределено;
		
	КонецЕсли;
	
	// на верхнем уровне корень - метаданные
	Если ДеревоПараметровВыгрузки.Строки.Количество() = 0 Тогда
		
		СтрокаСообщенияОбОшибке = "В ограничениях для выгрузки не найдена ни одна строка!";
		Возврат Неопределено;
		
	КонецЕсли;
	
	СтрокаМетаданных = ДеревоПараметровВыгрузки.Строки[0];
	
	Если Врег(СтрокаМетаданных.Имя) <> "METADATA" Тогда
		
		// не найден элемент метаданных
		СтрокаСообщенияОбОшибке = "Не найден элемент с именем METADATA  в настройках обмена данными";
		Возврат Неопределено;
		
	КонецЕсли;
	
	// побежали по сторокам метаданных
	Для Каждого СтрокаТиповМетаданных Из СтрокаМетаданных.Строки Цикл		
					
		Если Врег(СтрокаТиповМетаданных.Имя) = "CATALOGS"
			ИЛИ Врег(СтрокаТиповМетаданных.Имя) = "DOCUMENTS" Тогда 
			
			// Создадим структуры ответственные за выгрузку данных
			Для Каждого СтрокаДанных Из СтрокаТиповМетаданных.Строки Цикл
				
				СтруктураПараметровОграничений = СформироватьСтруктуруОграниченийДляВеткиМетаданных(СтрокаДанных, Врег(СтрокаТиповМетаданных.Имя), Ложь);
				СтрокаДанных.СтруктураОграничений = СтруктураПараметровОграничений;
				
				// все не нужное удаляем
				Если Не ВключатьПодчиненныеВетвиОбъектов Тогда
					СтрокаДанных.Строки.Очистить();
				Конецесли;
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ДеревоПараметровВыгрузки;

КонецФункции

//Функция формирует пакет для обмена данными
Функция СформироватьXMLДляОбменаСКПК(УзелОбмена, Пользователь, Знач СтрокаНастроекОбмена, Знач ДеревоПараметровВыгрузки, СтруктураСтрокКлассов, СтруктураПараметровОбменаДанными,
	                                 МетаданныеКонстант, МетаданныеСправочников, МетаданныеДокументов, МетаданныеРегистровСведений) Экспорт
    		
	
	ИтоговаяCтрокаЗаписи = "";
	
	// Создаем объект записи XML
	ЗаписьXML = Новый ЗаписьXML;
	
	ЗаписьXML.УстановитьСтроку("UTF-8");
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	ЗаписьXML.ЗаписатьНачалоЭлемента("_1CV8MobileAppData", "http://www.1c.ru/V8/1CV8MobileAppData/");
	ЗаписьXML.ЗаписатьСоответствиеПространстваИмен("V8MobileAppExch", "http://www.1c.ru/V8/1CV8MobileAppData/");
	ЗаписьXML.ЗаписатьСоответствиеПространстваИмен("xsi", "http://www.w3.org/2001/XMLSchema-instance");
	ЗаписьXML.ЗаписатьСоответствиеПространстваИмен("v8",  "http://v8.1c.ru/data");
	
	ТипДанныхУдаления = Тип("УдалениеОбъекта");
	
	// Сформируем секцию очистки данных в соответствии с заданными настройками обмена
	ЗаписатьСекциюОчисткиДанных(ЗаписьXML, ДеревоПараметровВыгрузки);
	
	// Получим данные, которые не регистрируются планом обмена 
	ЗаписатьИнформациюОбОбъектахБезРегистрацииИзменений(Пользователь,ЗаписьXML, ДеревоПараметровВыгрузки, СтруктураСтрокКлассов, СтруктураПараметровОбменаДанными);
		
	ЗаписьСообщения = ПланыОбмена.СоздатьЗаписьСообщения();
	
	ВременаяЗаписьXML = Новый ЗаписьXML;
	ВременаяЗаписьXML.УстановитьСтроку();
	ЗаписьСообщения.НачатьЗапись(ВременаяЗаписьXML, УзелОбмена);
			
	// Получаем выборку изменённых данных
	ВыборкаИзменений = ПланыОбмена.ВыбратьИзменения(УзелОбмена, ЗаписьСообщения.НомерСообщения);
	Пока ВыборкаИзменений.Следующий() Цикл
		
		// имененный элемент
		Данные = ВыборкаИзменений.Получить();
		
		// данные должны быть
		Если Данные = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ЭтоУдаление = (ТипДанныхУдаления = ТипЗнч(Данные));
		
		Если ЭтоУдаление Тогда
			МетаданныеОбъекта = Данные.Ссылка.Метаданные();
		Иначе	
			МетаданныеОбъекта = Данные.Метаданные();
		КонецЕсли;
		
		// определяем делать ли выгрузку того что отобрали или нет...
		СтрокаНайденногоПараметра = Неопределено;
		ЭтоСправочник = Ложь;
		ЭтоДокумент = Ложь;
		НужноВыгружать = Ложь;
		
		Если МетаданныеСправочников.Найти(МетаданныеОбъекта) <> Неопределено Тогда
			
			// справочники
			НужноВыгружать = ОпределитьПоИмениОбъектаМетаданныхНужноВыгружать(МетаданныеОбъекта.Имя, СтруктураСтрокКлассов.Справочники, СтрокаНайденногоПараметра);
			ЭтоСправочник = Истина;
			
		ИначеЕсли МетаданныеДокументов.Найти(МетаданныеОбъекта) <> Неопределено Тогда
			
			// документы
			НужноВыгружать = ОпределитьПоИмениОбъектаМетаданныхНужноВыгружать(МетаданныеОбъекта.Имя, СтруктураСтрокКлассов.Документы, СтрокаНайденногоПараметра);
			ЭтоДокумент = Истина;
					
		ИначеЕсли МетаданныеРегистровСведений.Найти(МетаданныеОбъекта) <> Неопределено Тогда
			
			// Регистры сведений
			НужноВыгружать = ОпределитьПоИмениОбъектаМетаданныхНужноВыгружать(МетаданныеОбъекта.Имя, СтруктураСтрокКлассов.РегистрыСведений, СтрокаНайденногоПараметра);
			
			// Для штрихкодов - отдельная проверка	
			Если (МетаданныеОбъекта.Имя = "ШтрихкодыДляМобильныхПриложений") И (НужноВыгружать) Тогда
				Если Не СтруктураПараметровОбменаДанными.ПолучатьШтрихкоды Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			// Для остатков - отдельная проверка	
			Если (МетаданныеОбъекта.Имя = "ОстаткиНаСкладахДляМобильныхИБ") И (НужноВыгружать) Тогда
				Если Не СтруктураПараметровОбменаДанными.ПолучатьОстаткиВВидеРегистраСведений Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли МетаданныеКонстант.Найти(МетаданныеОбъекта) <> Неопределено Тогда
			
			// Константы	
			НужноВыгружать = ОпределитьПоИмениОбъектаМетаданныхНужноВыгружать(МетаданныеОбъекта.Имя, СтруктураСтрокКлассов.Константы, СтрокаНайденногоПараметра);
						
		КонецЕсли;
		
		// выгружать не нужно - ничего не делаем
		Если Не НужноВыгружать Тогда
			Продолжить;
		КонецЕсли;
		
		// непоследственно сама процедура выгрузки данных
		Если ЭтоУдаление Тогда
			
			// стандартно записываем что есть
			ЗаписатьXML(ЗаписьXML, Данные);
			
		ИначеЕсли ЭтоСправочник Тогда
			
			// справочник
			ЗаписатьИнформациюОДанныхЭлементаСправочника(ЗаписьXML, СтрокаНайденногоПараметра.СтруктураОграничений, Данные);
			
		ИначеЕсли ЭтоДокумент Тогда	
			
			//документ
			ЗаписатьинформациюОДанныхДокумента(ЗаписьXML, СтрокаНайденногоПараметра.СтруктураОграничений, Данные);
			
		Иначе
			
			// все остальное выгружаем стандартным образом
			ЗаписатьXML(ЗаписьXML, Данные);
			
		КонецЕсли;
			
	КонецЦикла;
	
	ЗаписьXML.ЗаписатьКонецЭлемента(); //V8Exc:_1CV8MobileAppData
	
	// Завершаем запись сообщения
	ЗаписьСообщения.ЗакончитьЗапись();
	
	ИтоговаяCтрокаЗаписи = ЗаписьXML.Закрыть();
		    		
	Возврат ИтоговаяCтрокаЗаписи;
	
КонецФункции

//Процедура производит чтение данных из XML до конца текущего элемента
Процедура ПрочитатьДоКонцаЭлемента(XMLПоток)
	
	СчитатьЭлементыXMLВДерево(XMLПоток, Неопределено, 1);
	
КонецПроцедуры

//Функция получает по стрковуму GUID ссылку на объект
Функция ПолучитьПоGUIDСсылкуНаОбъект(Знач СтрокаGUID, Знач ИмяКлассаДанных, Знач ИмяТипаДанных)
	
	Если СтрокаGUID = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;		
	
	Если ИмяКлассаДанных = "CATALOGOBJECT"
		ИЛИ ИмяКлассаДанных = "CATALOGREF" Тогда
		
		СсылкаНаЭлемент = XMLЗначение(Тип("СправочникСсылка." + ИмяТипаДанных), СтрокаGUID);
				
	ИначеЕсли ИмяКлассаДанных = "DOCUMENTOBJECT"
		ИЛИ ИмяКлассаДанных = "DOCUMENTREF" Тогда
		
		СсылкаНаЭлемент = XMLЗначение(Тип("ДокументСсылка." + ИмяТипаДанных), СтрокаGUID);
			
	КонецЕсли;
	
	Возврат СсылкаНаЭлемент;
	
КонецФункции

//Функция по типу данных определяет класс и имя типа данных элемента
Функция ОпределитьПоТипуДанныхКлассИИмяТипа(Знач ТипДанных, ИмяКлассаДанных, ИмяТипаДанных)
	
	ПозицияТочки = Найти(ТипДанных, ".");
	ИмяТипаДанных = "";
	Если ПозицияТочки > 0 Тогда
			
		ИмяКлассаДанных = Врег(Сред(ТипДанных, 1, ПозицияТочки - 1)); 
		ИмяТипаДанных = Врег(Сред(ТипДанных, ПозицияТочки + 1));
			
	Иначе
		// тип не удалось определить
		ИмяКлассаДанных = Врег(ТипДанных);
			
	КонецЕсли;
	
КонецФункции

//Функция по типам данных реквизита определяет его строковое соответствие
Функция ОпределитьПоТипамДанныхРеквизитаСтроковыйАналог(ТипыДанныхРеквизита)
	
	Если ТипыДанныхРеквизита.Количество() > 1 Тогда
		Возврат "";
	Иначе
		ТипДанных = ТипыДанныхРеквизита[0];
		
		Если ТипДанных = Тип("Строка") Тогда
			Возврат "XSD:STRING";
			
		ИначеЕсли ТипДанных = Тип("Число") Тогда
			Возврат "XSD:DECIMAL";
			
		ИначеЕсли ТипДанных = Тип("Дата") Тогда
			Возврат "XSD:DATETIME";	
			
		ИначеЕсли ТипДанных = Тип("Булево") Тогда
			Возврат "XSD:BOOLEAN";
			
		ИначеЕсли Справочники.ТипВсеСсылки().СодержитТип(ТипДанных) Тогда
			
			ИмяКласса = "CATALOGREF";
			ЭлементСправочника = Новый(ТипДанных);
			ИмяОбъекта = Врег(ЭлементСправочника.Метаданные().Имя);
			
			Возврат ИмяКласса + "." + ИмяОбъекта;
			
		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипДанных) Тогда
			
			ИмяКласса = "DOCUMENTREF";
			НовыйДокумент = Новый(ТипДанных);
			ИмяОбъекта = Врег(НовыйДокумент.Метаданные().Имя);
			
			Возврат ИмяКласса + "." + ИмяОбъекта;
			
		ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипДанных) Тогда	
			
	    	ИмяКласса = "ENUMREF";
			ЭлементПеречисления = Новый(ТипДанных);
			ИмяОбъекта = Врег(ЭлементПеречисления.Метаданные().Имя);
			
			Возврат ИмяКласса + "." + ИмяОбъекта;
			
		ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипДанных) Тогда	
			
	    	ИмяКласса = "CHARTOFCHARACTERISTICTYPRESREF";
			ЭлементПВХ = Новый(ТипДанных);
			ИмяОбъекта = Врег(ЭлементПВХ.Метаданные().Имя);
			
			Возврат ИмяКласса + "." + ИмяОбъекта;	
			
		ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипДанных) Тогда	
			
	    	ИмяКласса = "CHARTOFACCOUNTSREF";
			ЭлементПC = Новый(ТипДанных);
			ИмяОбъекта = Врег(ЭлементПC.Метаданные().Имя);
			
			Возврат ИмяКласса + "." + ИмяОбъекта;
			
		ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипДанных) Тогда	
			
	    	ИмяКласса = "CHARTOFCALCULATIONREF";
			ЭлементПВР = Новый(ТипДанных);
			ИмяОбъекта = Врег(ЭлементПВР.Метаданные().Имя);
			
			Возврат ИмяКласса + "." + ИмяОбъекта;			
			
		ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипДанных) Тогда	
			
	    	ИмяКласса = "EXCHANGEPLANREF";
			ЭлементПО = Новый(ТипДанных);
			ИмяОбъекта = Врег(ЭлементПО.Метаданные().Имя);
			
			Возврат ИмяКласса + "." + ИмяОбъекта;
							
		ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипДанных) Тогда	
			
	    	ИмяКласса = "BUSINESSPROCESSREF";
			НовыйБП = Новый(ТипДанных);
			ИмяОбъекта = Врег(НовыйБП.Метаданные().Имя);
			
			Возврат ИмяКласса + "." + ИмяОбъекта;	
			
		ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипДанных) Тогда	
			
	    	ИмяКласса = "TASKREF";
			НоваяЗадача = Новый(ТипДанных);
			ИмяОбъекта = Врег(НоваяЗадача.Метаданные().Имя);
			
			Возврат ИмяКласса + "." + ИмяОбъекта;	
			
		ИначеЕсли ТипДанных = Тип("ДвоичныеДанные") Тогда
			
			Возврат "XSD:BASE64BINARY";
			
		ИначеЕсли ТипДанных = Тип("ХранилищеЗначения") Тогда
			
			Возврат "V8:VALUESTORAGE";	
			
		Иначе
			
			СообщитьОбОшибке("Невозможно определить тип данных: " + Строка(ТипДанных));
			
		КонецЕсли;
		
	КонецЕсли;
		
КонецФункции

//Функция преобразует строку XML к булевскому типу
Функция ПолучитьБулевыйТипПоСтроковомуЗначениюXML(Знач СтроковоеЗначение)
	
	Возврат XMLЗначение(Тип("Булево"), СтроковоеЗначение);
	
КонецФункции

//Функция по значению для выгрузке и типу элемента определяет ссылку на значение
Функция ОпределитьСсылкуНаЗначениеПоДаннымИТипу(Знач ТипДанных, Знач СтроковоеЗначение)
	
	Если СтроковоеЗначение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// по типу определяем где искать
	ИмяКлассаДанных = "";
	ИмяТипаДанных = "";
	ОпределитьПоТипуДанныхКлассИИмяТипа(ТипДанных, ИмяКлассаДанных, ИмяТипаДанных);
	
	Если ПустаяСтрока(ИмяКлассаДанных) Тогда
		СообщитьОбОшибке("Неизвестный тип данных: " + ТипДанных);
		Возврат Неопределено;
	КонецЕсли;
	
	Если ИмяКлассаДанных = "CATALOGOBJECT"
		ИЛИ ИмяКлассаДанных = "CATALOGREF"
		ИЛИ ИмяКлассаДанных = "DOCUMENTOBJECT"
		ИЛИ ИмяКлассаДанных = "DOCUMENTREF" Тогда
		
		СсылкаПоиска = ПолучитьПоGUIDСсылкуНаОбъект(СтроковоеЗначение, ИмяКлассаДанных, ИмяТипаДанных);
		
	ИначеЕсли ИмяКлассаДанных = "XSD:STRING" Тогда
		СсылкаПоиска = XMLЗначение(Тип("Строка"), СтроковоеЗначение);
		
	ИначеЕсли ИмяКлассаДанных = "XSD:DECIMAL" Тогда
		СсылкаПоиска = XMLЗначение(Тип("Число"), СтроковоеЗначение);	
		
	ИначеЕсли ИмяКлассаДанных = "XSD:DATETIME" Тогда
		СсылкаПоиска = XMLЗначение(Тип("Дата"), СтроковоеЗначение);
		
	ИначеЕсли ИмяКлассаДанных = "XSD:BOOLEAN" Тогда
		СсылкаПоиска = ПолучитьБулевыйТипПоСтроковомуЗначениюXML(СтроковоеЗначение);

	ИначеЕсли ИмяКлассаДанных = "ENUMREF" Тогда
		
		СсылкаПоиска = XMLЗначение(Тип("ПеречислениеСсылка." + ИмяТипаДанных), СтроковоеЗначение);
		
	ИначеЕсли ИмяКлассаДанных = "XSI:NIL" Тогда
		СсылкаПоиска = Неопределено;
		
	ИначеЕсли ИмяКлассаДанных = "XSD:BASE64BINARY" Тогда
		// бинарные данные
		СсылкаПоиска = XMLЗначение(Тип("ДвоичныеДанные"), СтроковоеЗначение);
		
	ИначеЕсли ИмяКлассаДанных = "V8:VALUESTORAGE" Тогда	
		// хранилище значений
		СсылкаПоиска = XMLЗначение(Тип("ХранилищеЗначения"), СтроковоеЗначение);
						
	Иначе
		СообщитьОбОшибке("Неизвестный тип данных: " + ТипДанных);
		Возврат Неопределено;
		
	КонецЕсли;

	Возврат СсылкаПоиска;
	
КонецФункции


//Функция возвращает элемент для изменения по дереву параметров
Функция ПолучитьОбъектДляИзмененияПоДеревуДанных(Знач ИмяКлассаДанных, Знач ИмяТипаДанных, ДеревоПараметров)
	
	СтрокаСсылки = ДеревоПараметров.Строки.Найти("Ref", "Имя");
	
	// не нашли ссылку
	Если СтрокаСсылки = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтроковоеЗначение = ПолучитьЗначениеУзлаДерева(СтрокаСсылки);
	СсылкаНаЭлемент = ОпределитьСсылкуНаЗначениеПоДаннымИТипу(ИмяКлассаДанных + "." + ИмяТипаДанных, СтроковоеЗначение);
    	
	ОбъектДанных = СсылкаНаЭлемент.ПолучитьОбъект();
	
	// объект и так нашли
	Если ОбъектДанных <> Неопределено Тогда
		Возврат ОбъектДанных;
	КонецЕсли;
	
	Если ИмяКлассаДанных = "CATALOGOBJECT" Тогда
		
		// определяем идет работа с группой или нет
		СтрокаГруппы = ДеревоПараметров.Строки.Найти("IsFolder", "Имя");
			
		ЭтоГруппа = (СтрокаГруппы <> Неопределено);
			
		Если ЭтоГруппа Тогда
			
			Попытка
				СтроковоеЗначениеЭтоГруппа = ПолучитьЗначениеУзлаДерева(СтрокаГруппы);
				БулевоеЗначениеЭтоГруппа = ПолучитьБулевыйТипПоСтроковомуЗначениюXML(СтроковоеЗначениеЭтоГруппа);
				ЭтоГруппа = БулевоеЗначениеЭтоГруппа;
			Исключение
				ЭтоГруппа = Ложь;	
			КонецПопытки;
				
		КонецЕсли;
			
		Если ЭтоГруппа Тогда
			ОбъектДанных = Справочники[ИмяТипаДанных].СоздатьГруппу();				
		Иначе
			ОбъектДанных = Справочники[ИмяТипаДанных].СоздатьЭлемент();				
		КонецЕсли;
		
		ОбъектДанных.УстановитьСсылкуНового(СсылкаНаЭлемент);
		
	ИначеЕсли ИмяКлассаДанных = "DOCUMENTOBJECT" Тогда
		
		ОбъектДанных = Документы[ИмяТипаДанных].СоздатьДокумент();
		ОбъектДанных.УстановитьСсылкуНового(СсылкаНаЭлемент);
				
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат ОбъектДанных;
	
КонецФункции

//Функция создает струкруру в которой хранятся данные по типам реквизитов (и реквизитов т.ч) у объекта
Функция СоздатьСтруктуруТиповРеквизитовДляОбъектов(ОбъектМетаданных)
	
	СтруктураТипов = Новый Структура();
	
	Для Каждого Реквизит Из ОбъектМетаданных Цикл
		
		СтрокаОписанияТипа = ОпределитьПоТипамДанныхРеквизитаСтроковыйАналог(Реквизит.Тип.Типы());
		
		Если Не ПустаяСтрока(СтрокаОписанияТипа) Тогда
			
			СтруктураТипов.Вставить(Реквизит.Имя, СтрокаОписанияТипа);	
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СтруктураТипов;	
	
КонецФункции

//Функция создает структуру хранения типов для объекта метаданных
Функция СоздатьСтруктуруТиповДляОбъектаМетаданных(ОбъектМетаданных)
	
	СтруктураТипов = Новый Структура();
	
	// записываем имя объекта метаданных
	СтруктураТипов.Вставить("Имя", ОбъектМетаданных.Имя);
	
	ЭтоСправочник = Ложь;
	
	// для справочников еще надо тип кода выгрузить
	Попытка
		Если ОбъектМетаданных.ТипКода = Метаданные.СвойстваОбъектов.ТипКодаСправочника.Строка Тогда
			СтруктураТипов.Вставить("ТипКода", "XSD:STRING");	
		Иначе
			СтруктураТипов.Вставить("ТипКода", "XSD:DECIMAL");
		КонецЕсли;
		
		ЭтоСправочник = Истина;
	Исключение
		// это не справочник
		
		Попытка
			// для документа ип номера надо опрелить
			Если ОбъектМетаданных.ТипНомера = Метаданные.СвойстваОбъектов.ТипНомераДокумента.Строка Тогда
				СтруктураТипов.Вставить("ТипНомера", "XSD:STRING");	
			Иначе
				СтруктураТипов.Вставить("ТипНомера", "XSD:DECIMAL");
			КонецЕсли;
			
		Исключение
			
		КонецПопытки;
		
	КонецПопытки;
	
	// реквизиты
	СтруктураРеквизитов = СоздатьСтруктуруТиповРеквизитовДляОбъектов(ОбъектМетаданных.Реквизиты);
	
	СтруктураТипов.Вставить("Реквизиты", СтруктураРеквизитов);
	
	СтруктураТабЧастей = Новый Структура();
	
	// таб части
	Для Каждого ТабЧасть Из ОбъектМетаданных.ТабличныеЧасти Цикл
		
		СтруктураТекущейТабЧасти = Новый Структура();
		
		СтруктураРеквизитов = СоздатьСтруктуруТиповРеквизитовДляОбъектов(ТабЧасть.Реквизиты);
		
		Если ЭтоСправочник Тогда
			// определям нужна ли таб часть для групп и элементов
			ОпределитьНеобходимостьВыгрузкиДляЭлементаИГруппы(ТабЧасть, СтруктураТекущейТабЧасти);
		КонецЕсли;
		
		// создадим вложенную в таб часть структуру реквизитов
		СтруктураТекущейТабЧасти.Вставить("Реквизиты", СтруктураРеквизитов);
		
		
		СтруктураТабЧастей.Вставить(ТабЧасть.Имя, СтруктураТекущейТабЧасти);
		
	КонецЦикла;                 
	
	СтруктураТипов.Вставить("ТабличныеЧасти", СтруктураТабЧастей);
	
	Возврат СтруктураТипов;	
	
КонецФункции


//Процедура устанавливает значение переменной из значения и типа строки дерева разбора XML
Процедура УстановитьЗначениеИзXML(СтрокаДерева, Знач НаименованиеАттрибута, Знач НаименованиеДокумента, СтруктураРеквизитов, РезультирующееЗначение)
	
	СтроковоеЗначениеРеквизита = ПолучитьЗначениеУзлаДерева(СтрокаДерева);
	
	Если СтруктураРеквизитов <> Неопределено Тогда
		
		ОписаниеТипаДанныхРеквизита = Неопределено;
		СтруктураРеквизитов.Свойство(НаименованиеАттрибута, ОписаниеТипаДанныхРеквизита);
	
	КонецЕсли;
				
	Если ОписаниеТипаДанныхРеквизита = Неопределено Тогда
		СтрокаТипаДанных = ПолучитьТипУзлаДерева(СтрокаДерева); 
	Иначе
		СтрокаТипаДанных = ОписаниеТипаДанныхРеквизита;
	КонецЕсли;
				
	Если ПустаяСтрока(СтрокаТипаДанных) Тогда
		СообщитьОбОшибке("Невозможно определить тип данных реквизита: " + НаименованиеАттрибута + " у объекта " + НаименованиеДокумента);
	КонецЕсли;
				
	РезультирующееЗначение = ОпределитьСсылкуНаЗначениеПоДаннымИТипу(СтрокаТипаДанных, СтроковоеЗначениеРеквизита);
	
КонецПроцедуры

//Процедура заполняет значениями табличную часть объекта
Процедура УстановитьТабличнуюЧастьИзXML(СтрокаДерева, Знач ПолныйПутьКТабЧасти, СтруктураРеквизитовТабЧасти, ТабличнаяЧастьОбъекта,
	Знач ЭтоГруппа = Неопределено)
	
	// надо определить выгружать таб часть или нет
	НужноПроизводитьЗагрузку = Истина;
		
	Если ЭтоГруппа <> Неопределено Тогда 
		НужноПроизводитьЗагрузку = ОпределитьНужноПроводитьВыгрузкуДляГруппыИЭлемента(ЭтоГруппа, СтруктураРеквизитовТабЧасти)
	КонецЕсли;
		
	Если Не НужноПроизводитьЗагрузку Тогда
		Возврат;
	КонецЕсли;
	
	// табличную часть полностью очищаем
	ТабличнаяЧастьОбъекта.Очистить();
				
	// заполняем строки таб части теми значениями что есть у нас
	Для Каждого СтрокаСтруктурыТабЧасти Из СтрокаДерева.Строки Цикл
				
		РеквизитыТабЧасти = СтруктураРеквизитовТабЧасти.Реквизиты;
		// всю строку переносим как есть из структуры в объект
		СтрокаОбъектаТабЧасти = ТабличнаяЧастьОбъекта.Добавить();
					
		// надо все реквизиты перенести, что заполнены
		Для Каждого СтрокаРеквизитов Из СтрокаСтруктурыТабЧасти.Строки Цикл
						
			УстановитьЗначениеИзXML(СтрокаРеквизитов, СтрокаРеквизитов.Имя, ПолныйПутьКТабЧасти, 
				РеквизитыТабЧасти, СтрокаОбъектаТабЧасти[СтрокаРеквизитов.Имя]);
						
		КонецЦикла;
					
	КонецЦикла;	
	
КонецПроцедуры

// процедура устанавливает значения реквизитов или табличных частей объекта
Процедура УстановитьРеквизитыИТабЧастиОбъектовИЗXML(Знач НаименованиеАттрибута, СтруктураРеквизитов, СтруктураТабЧастей, 
	ОбъектДляИзменения, СтрокаДерева, НаименованиеОбъекта, Знач ЭтоГруппа = Неопределено)
	
	// определяем что это таб часть или реквизит
	СтруктураРеквизитовТабЧасти = Неопределено; 
	СтруктураТабЧастей.Свойство(НаименованиеАттрибута, СтруктураРеквизитовТабЧасти);
			
	Если СтруктураРеквизитовТабЧасти = Неопределено Тогда
				
		УстановитьЗначениеИзXML(СтрокаДерева, НаименованиеАттрибута, НаименованиеОбъекта, СтруктураРеквизитов, ОбъектДляИзменения[НаименованиеАттрибута]);
								
	Иначе
		// это таб часть
		УстановитьТабличнуюЧастьИзXML(СтрокаДерева, НаименованиеОбъекта + "." + НаименованиеАттрибута, 
			СтруктураРеквизитовТабЧасти, ОбъектДляИзменения[НаименованиеАттрибута], ЭтоГруппа);
				
	КонецЕсли;
		
КонецПроцедуры		

	
//функция возвращает измененный элемент справочника
Функция ПрочитатьИИзменитьЭлементСправочника(ЧтениеXML, Знач СтруктураТипов)
	
	// считываем все данные в дерево
	ДеревоФайла = СоздатьЗаготовкуДереваДляСчитыванияданныхИзXML();
	СчитатьЭлементыXMLВДерево(ЧтениеXML, ДеревоФайла, 1);
	
	НаименованиеОбъектаИзменения = СтруктураТипов.Имя;
	
	ОбъектДляИзменения = ПолучитьОбъектДляИзмененияПоДеревуДанных("CATALOGOBJECT", НаименованиеОбъектаИзменения, ДеревоФайла);
	
	Если ОбъектДляИзменения = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураРеквизитов = СтруктураТипов.Реквизиты;
	СтруктураТабЧастей = СтруктураТипов.ТабличныеЧасти;
	
	//теперь надо пробежать по всем строкам дерева, и если это реквизит, то изменить его
	// а если табличная часть, то полностью ее переписать
	Для Каждого СтрокаДерева Из ДеревоФайла.Строки Цикл
		
		НаименованиеАттрибута = Врег(СтрокаДерева.Имя);
		Если НаименованиеАттрибута = "REF"
			ИЛИ НаименованиеАттрибута = "ISFOLDER" Тогда
			
			Продолжить;
			
		ИначеЕсли НаименованиеАттрибута = "DELETIONMARK" Тогда
			
			ЗначениеПометкиУдаления = ПолучитьЗначениеУзлаДерева(СтрокаДерева);
			ОбъектДляИзменения.ПометкаУдаления = ПолучитьБулевыйТипПоСтроковомуЗначениюXML(ЗначениеПометкиУдаления);
			
		ИначеЕсли НаименованиеАттрибута = "OWNER" Тогда
			
			// у владельца еще надо тип определить...
			Владелец = ПолучитьЗначениеУзлаДерева(СтрокаДерева);
			ТипДанных = ПолучитьТипУзлаДерева(СтрокаДерева);
			СсылкаНаВладельца = ОпределитьСсылкуНаЗначениеПоДаннымИТипу(ТипДанных, Владелец);
			
			ОбъектДляИзменения.Владелец = СсылкаНаВладельца;
			
		ИначеЕсли НаименованиеАттрибута = "PARENT" Тогда
			
			Родитель = ПолучитьЗначениеУзлаДерева(СтрокаДерева);
			СсылкаНаРодителя = ОпределитьСсылкуНаЗначениеПоДаннымИТипу("CATALOGOBJECT." + НаименованиеОбъектаИзменения, Родитель);
			
			ОбъектДляИзменения.Родитель = СсылкаНаРодителя;
			
		ИначеЕсли НаименованиеАттрибута = "CODE" Тогда
			
			Код = ПолучитьЗначениеУзлаДерева(СтрокаДерева);
			ЗначениеКода = ОпределитьСсылкуНаЗначениеПоДаннымИТипу(СтруктураТипов.ТипКода, Код);
			
			ОбъектДляИзменения.Код = ЗначениеКода;
			
		ИначеЕсли НаименованиеАттрибута = "DESCRIPTION" Тогда
			
			Наименование = ПолучитьЗначениеУзлаДерева(СтрокаДерева);
			ОбъектДляИзменения.Наименование = Наименование;
			
		Иначе
			// нащли реквизиты и таб части
			УстановитьРеквизитыИТабЧастиОбъектовИЗXML(НаименованиеАттрибута, СтруктураРеквизитов, СтруктураТабЧастей, 
				ОбъектДляИзменения, СтрокаДерева, НаименованиеОбъектаИзменения, ОбъектДляИзменения.ЭтоГруппа);
					
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ОбъектДляИзменения;
	
КонецФункции

//функция возвращает измененный документ
Функция ПрочитатьИИзменитьДокумент(ЧтениеXML, Знач СтруктураТипов)
	
	// считываем все данные в дерево
	ДеревоФайла = СоздатьЗаготовкуДереваДляСчитыванияданныхИзXML();
	СчитатьЭлементыXMLВДерево(ЧтениеXML, ДеревоФайла, 1);
	
	НаименованиеОбъектаИзменения = СтруктураТипов.Имя;
	
	ОбъектДляИзменения = ПолучитьОбъектДляИзмененияПоДеревуДанных("DOCUMENTOBJECT", НаименованиеОбъектаИзменения, ДеревоФайла);
	
	Если ОбъектДляИзменения = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураРеквизитов = СтруктураТипов.Реквизиты;
	СтруктураТабЧастей = СтруктураТипов.ТабличныеЧасти;
	
	//теперь надо пробежать по всем строкам дерева, и если это реквизит, то изменить его
	// а если табличная часть, то полностью ее переписать
	Для Каждого СтрокаДерева Из ДеревоФайла.Строки Цикл
		
		НаименованиеАттрибута = Врег(СтрокаДерева.Имя);
		Если НаименованиеАттрибута = "REF" Тогда
			
			Продолжить;
			
		ИначеЕсли НаименованиеАттрибута = "DELETIONMARK" Тогда
			
			ЗначениеПометкиУдаления = ПолучитьЗначениеУзлаДерева(СтрокаДерева);
			ОбъектДляИзменения.ПометкаУдаления = ПолучитьБулевыйТипПоСтроковомуЗначениюXML(ЗначениеПометкиУдаления);
			
		ИначеЕсли НаименованиеАттрибута = "DATE" Тогда
			
			// у владельца еще надо тип определить...
			СтрокаДатыДокумента = ПолучитьЗначениеУзлаДерева(СтрокаДерева);
			ДатаДокумента = ОпределитьСсылкуНаЗначениеПоДаннымИТипу("XSD:DATETIME", СтрокаДатыДокумента);
			
			ОбъектДляИзменения.Дата = ДатаДокумента;
			
		ИначеЕсли НаименованиеАттрибута = "NUMBER" Тогда
			
			// надо определить тип номера документа
			СтрокаНомераДокумента = ПолучитьЗначениеУзлаДерева(СтрокаДерева);
			НомерДокумента = ОпределитьСсылкуНаЗначениеПоДаннымИТипу(СтруктураТипов.ТипНомера, СтрокаНомераДокумента); 
			
			ОбъектДляИзменения.Номер = НомерДокумента;
			
		ИначеЕсли НаименованиеАттрибута = "POSTED" Тогда
			
			СтрокаПроведенияДокумента = ПолучитьЗначениеУзлаДерева(СтрокаДерева);
			ОбъектДляИзменения.Проведен = ПолучитьБулевыйТипПоСтроковомуЗначениюXML(СтрокаПроведенияДокумента);
			
		Иначе
			// нащли реквизиты и таб части
			УстановитьРеквизитыИТабЧастиОбъектовИЗXML(НаименованиеАттрибута, СтруктураРеквизитов, СтруктураТабЧастей, 
				ОбъектДляИзменения, СтрокаДерева, НаименованиеОбъектаИзменения);
					
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ОбъектДляИзменения;
	
КонецФункции

//Процедура записывает изменения в информационную базу, переданных с КПК
Процедура ПринятьИзмененияОтКПК(УзелОбмена, Знач СтрокаИзменений) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаИзменений);
	
	// проверка формата файла обмена
	Если Не ЧтениеXML.Прочитать() Или
		ЧтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента Или 
		ЧтениеXML.ЛокальноеИмя <> "_1CV8MobileAppData" Или 
		ЧтениеXML.URIПространстваИмен <> "http://www.1c.ru/V8/1CV8MobileAppData/" Тогда
		
		СообщитьОбОшибке("Неверный формат данных: Не корректное начало файла");
		Возврат;
		
	КонецЕсли;
			
	// чтение и запись в ИБ записанных в выгрузке объектов
	Если Не ЧтениеXML.Прочитать() Тогда 		
		
		СообщитьОбОшибке("Нет данных для чтения изменений в файле обмена");
		Возврат;
		
	КонецЕсли;
	
	СтруктураТиповДанныхСправочников = Новый Структура();
	СтруктураТиповДанныхДокументов = Новый Структура();
    		
	Пока ВозможностьЧтенияXML(ЧтениеXML) Цикл
		
		ТипXML = ПолучитьXMLТип(ЧтениеXML);
		Если ТипXML = Неопределено Тогда
			
			ПрочитатьДоКонцаЭлемента(ЧтениеXML);
			Продолжить;		
			
		КонецЕсли; 
		
		ИмяКлассаДанных = "";
		ИмяТипаДанных = "";
		ОпределитьПоТипуДанныхКлассИИмяТипа(ТипXML.ИмяТипа, ИмяКлассаДанных, ИмяТипаДанных);
		
		Если ПустаяСтрока(ИмяКлассаДанных) Тогда
			
			// что то непонятное ...
			ПрочитатьДоКонцаЭлемента(ЧтениеXML);
			Продолжить;
			
		КонецЕсли;
		
		// надо правильно загружать объекты у которых переданы не все реквизиты
				
		// непосредственно само чтение данных
		ОбъектЧтения = Неопределено;
		
		Если ИмяКлассаДанных = "CATALOGOBJECT" Тогда
			
			СтруктураТипов = Неопределено;
			Если НЕ СтруктураТиповДанныхСправочников.Свойство(ИмяТипаДанных, СтруктураТипов) Тогда
			
				СтруктураТипов = СоздатьСтруктуруТиповДляОбъектаМетаданных(Метаданные.Справочники.Найти(ИмяТипаДанных));
			    СтруктураТиповДанныхСправочников.Вставить(ИмяТипаДанных, СтруктураТипов);
				
			КонецЕсли;
			
			// читаем элемент справочника
			ОбъектЧтения = ПрочитатьИИзменитьЭлементСправочника(ЧтениеXML, СтруктураТипов);
			
		ИначеЕсли ИмяКлассаДанных = "DOCUMENTOBJECT" Тогда
			
			СтруктураТипов = Неопределено;
			Если НЕ СтруктураТиповДанныхДокументов.Свойство(ИмяТипаДанных, СтруктураТипов) Тогда
			
				СтруктураТипов = СоздатьСтруктуруТиповДляОбъектаМетаданных(Метаданные.Документы.Найти(ИмяТипаДанных));
			    СтруктураТиповДанныхДокументов.Вставить(ИмяТипаДанных, СтруктураТипов);
				
			КонецЕсли;
			
			//читаем документ
			ОбъектЧтения = ПрочитатьИИзменитьДокумент(ЧтениеXML, СтруктураТипов);
			
		Иначе	
			
			ОбъектЧтения = ПрочитатьXML(ЧтениеXML);
			
		КонецЕсли;
		
		// нечего записывать, когда ничего не прочитали
		Если ОбъектЧтения = Неопределено Тогда
			
			ПрочитатьДоКонцаЭлемента(ЧтениеXML);
			Продолжить;
			
		КонецЕсли;
		
		Если ПланыОбмена.ИзменениеЗарегистрировано(УзелОбмена, ОбъектЧтения) Тогда
			// следить за тем, что измененные на строне главной базы объекты не переписывались со стороны КПК
			Продолжить;
		КонецЕсли;
		
		ОбъектЧтения.ОбменДанными.Загрузка = Истина;

		МетаданныеПланаОбмена = УзелОбмена.Метаданные();
		Если МетаданныеПланаОбмена.Состав.Содержит(ОбъектЧтения.Метаданные()) Тогда
			ОбъектЧтения.ОбменДанными.Отправитель = УзелОбмена;
		КонецЕсли;
		
		ОбъектЧтения.Записать();
				
	КонецЦикла;
		
	// проверка формата файла обмена		
	ЧтениеXML.Закрыть();
	
КонецПроцедуры

